

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pySPACE.missions.nodes.templates &mdash; pySPACE 0.5 alpha documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/pySPACE.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.5 alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/pyspace-logo.ico"/>
    <link rel="top" title="pySPACE 0.5 alpha documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">pySPACE 0.5 alpha documentation</a> &raquo;</li>
          <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/pyspace-logo_small.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pySPACE.missions.nodes.templates</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot; Tell the developer about general coding and documentation approaches for nodes</span>

<span class="sd">The first line in each module/class/function docstring should be short,</span>
<span class="sd">in imperative, without stop and explain, what it does.</span>
<span class="sd">You should **not** copy it from elsewhere, because if you overwrite</span>
<span class="sd">existing routines, they should be different and such differ in documentation.</span>
<span class="sd">If you really can not help, copying code, you should at least document,</span>
<span class="sd">where you took it from.</span>

<span class="sd">Detailed information on documentation guidelines can be found</span>
<span class="sd">:ref:`here &lt;doc&gt;`.</span>
<span class="sd">Before writing your own node, you have to have a look at it, because every node</span>
<span class="sd">must be documented!</span>
<span class="sd">You should also have a look at the documentation of the</span>
<span class="sd">:mod:`~pySPACE.missions.nodes` package</span>

<span class="sd">.. note:: Some parts of the guidelines, will be copied to this place,</span>
<span class="sd">          because of their importance.</span>

<span class="sd">Coding Guidelines</span>
<span class="sd">-----------------</span>

<span class="sd">Before programming a node or overwriting an method, have a look at this</span>
<span class="sd">documentation and the documentation in the</span>
<span class="sd">:class:`~pySPACE.missions.nodes.base_node.BaseNode`, because otherwise</span>
<span class="sd">you might get unwanted side effects.</span>
<span class="sd">Furthermore, you should have a look at existing code and mainly follow</span>
<span class="sd">the `PEP 8 coding style &lt;http://www.python.org/dev/peps/pep-0008/&gt;`_</span>

<span class="sd">How is the node accessed? - Some naming conventions</span>
<span class="sd">----------------------------------------------------</span>

<span class="sd">The :mod:`~pySPACE.missions.nodes` package supports automatic loading of nodes.</span>
<span class="sd">The easiest access then is via the</span>
<span class="sd">:mod:`node chains &lt;pySPACE.environments.chains.node_chain&gt;` in the</span>
<span class="sd">:mod:`node chain operation &lt;pySPACE.missions.operations.node_chain&gt;`.</span>
<span class="sd">Their, your new implemented node needs a name.</span>
<span class="sd">To be detected as node, your node has to end with **`Node`**.</span>
<span class="sd">Node names are written in CamelCase.</span>
<span class="sd">Automatic node names are the class name and the class name without the</span>
<span class="sd">ending **Node**.</span>
<span class="sd">If you want to have extra names or backward compatibility after changing names,</span>
<span class="sd">you can define or extend a dictionary with the name</span>
<span class="sd">**_NODE_MAPPING** at the end of each module implementation.</span>
<span class="sd">As keys you use the new names and the value is the corresponding class name.</span>
<span class="sd">Be careful to use meaningful names or abbreviations, which are not already</span>
<span class="sd">:ref:`in use &lt;node_list&gt;`.</span>

<span class="sd">When the documentation is generated, the available names are added</span>
<span class="sd">automatically to the documentation of each node and additionally</span>
<span class="sd">:ref:`complete lists &lt;node_list&gt;` are generated to give information</span>
<span class="sd">on available nodes and their functionality.</span>

<span class="sd">Base nodes should always include **&quot;Base&quot;** in their class name</span>
<span class="sd">and if they are not usable they should end with it instead of **&quot;Node&quot;**.</span>

<span class="sd">The First Step: Where to put the node?</span>
<span class="sd">--------------------------------------</span>

<span class="sd">Finding the Category</span>
<span class="sd">+++++++++++++++++++++</span>

<span class="sd">Before implementing your own node, you should find out, where to put it.</span>
<span class="sd">The :mod:`~pySPACE.missions.nodes` has several categories of algorithms</span>
<span class="sd">and you should check their documentation to find out, where your node belongs to.</span>

<span class="sd">Finding the Module</span>
<span class="sd">+++++++++++++++++++</span>

<span class="sd">As the next step, you should find out, if there is already a fitting module in</span>
<span class="sd">there, which fits to your algorithm or needs only small change in</span>
<span class="sd">documentation, to be fitting.</span>

<span class="sd">If there is no module, you have to open up your own new one.</span>

<span class="sd">.. warning:: Be careful, when creating new modules. The module name should be</span>
<span class="sd">             meaningful. The module should include some basic documentation and</span>
<span class="sd">             most importantly describe a general concept of a group</span>
<span class="sd">             of algorithms and not repeat the documentation of your new class.</span>

<span class="sd">.. note:: When the documentation is generated, at the end of each module</span>
<span class="sd">          documentation, a summary of its functions and classes is generated.</span>
<span class="sd">          So you should not do this manually.</span>

<span class="sd">Finding the Class Name</span>
<span class="sd">+++++++++++++++++++++++</span>

<span class="sd">The class name is written with the above mentioned conventions.</span>
<span class="sd">But before starting with it, you should first check,</span>
<span class="sd">if there is already a class, which only has to be modified for your new part.</span>
<span class="sd">Second you should check if your algorithms is developed for a very special</span>
<span class="sd">purpose but could be generalized.</span>
<span class="sd">Finally you decide for a short meaningful algorithm name, which</span>
<span class="sd">contrasts your algorithm from the exiting ones.</span>

<span class="sd">Base Nodes</span>
<span class="sd">++++++++++</span>

<span class="sd">For some highly sophisticated types of nodes you can find a corresponding</span>
<span class="sd">base node in the package.</span>
<span class="sd">The :mod:`~pySPACE.missions.nodes.visualization` package is the best example</span>
<span class="sd">in this case.</span>
<span class="sd">Theses nodes define a special interface for your algorithm and you will only</span>
<span class="sd">have to implement some special functions for these nodes,</span>
<span class="sd">which can be found in their documentation.</span>

<span class="sd">Currently the default is, that your node is not inheriting from any special</span>
<span class="sd">generalizing base node but only from the basic</span>
<span class="sd">:class:`~pySPACE.missions.nodes.base_node.BaseNode`.</span>
<span class="sd">This node is by default just forwarding the data, but implements all</span>
<span class="sd">functionality a node needs.</span>

<span class="sd">The Main Principle</span>
<span class="sd">------------------</span>

<span class="sd">Every node, which is no base node should inherit from the base node.</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    from pySPACE.missions.nodes.base_node import BaseNode</span>

<span class="sd">Implementing a node now is nothing more than carefully overwriting the</span>
<span class="sd">default methods of this node.</span>
<span class="sd">Depending on the complexity of your algorithm, this might be very easy or a bit</span>
<span class="sd">more complicated. In the following we will give advice and examples therefore.</span>

<span class="sd">The Processed Data Types - Input and Output</span>
<span class="sd">--------------------------------------------</span>

<span class="sd">For processing only special input and output types are required,</span>
<span class="sd">which are subclasses of numpy arrays.</span>
<span class="sd">All currently available types can be found in</span>
<span class="sd">:mod:`pySPACE.resources.data_types`.</span>


<span class="sd">Further Minor Information</span>
<span class="sd">-------------------------</span>

<span class="sd">* Randomization should be done be setting a fixed seed with the help of</span>
<span class="sd">  *self.run_number* to enable reproducibility.</span>
<span class="sd">* The here presented nodes are only examples</span>
<span class="sd">  for better documentation of the node creation process</span>
<span class="sd">  and should not be taken to serious</span>
<span class="sd">  or used as base nodes for real algorithms.</span>
<span class="sd">* A special end of a node chain can be a *sink node*.</span>
<span class="sd">  It is defined by implementing the method *get_result_dataset*.</span>
<span class="sd">  Its function is to gather all data.</span>
<span class="sd">* The variable *self.temp_dir* an be used to store some data temporarily,</span>
<span class="sd">  e.g. for security reasons.</span>

<span class="sd">General Concept of a Node</span>
<span class="sd">-------------------------</span>

<span class="sd">.. image:: ../../graphics/node.png</span>
<span class="sd">   :width: 500</span>

<span class="sd">Integration of Nodes in a :mod:`~pySPACE.environments.chains.node_chain`</span>
<span class="sd">-------------------------------------------------------------------------</span>

<span class="sd">.. image:: ../../graphics/node_chain.png</span>
<span class="sd">   :width: 500</span>

<span class="sd">Usage of :mod:`node chains &lt;pySPACE.environments.chains.node_chain&gt;`</span>
<span class="sd">--------------------------------------------------------------------</span>

<span class="sd">.. image:: ../../graphics/launch_live.png</span>
<span class="sd">   :width: 500</span>

<span class="sd">Visualization of :mod:`~pySPACE.missions.nodes.splitter` Nodes</span>
<span class="sd">--------------------------------------------------------------</span>

<span class="sd">.. image:: ../../graphics/splitter.png</span>
<span class="sd">    :width: 500</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pySPACE.missions.nodes.base_node</span> <span class="kn">import</span> <span class="n">BaseNode</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pySPACE.resources.data_types.feature_vector</span> <span class="kn">import</span> <span class="n">FeatureVector</span>

<div class="viewcode-block" id="SimpleDataTransformationTemplateNode"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleDataTransformationTemplateNode">[docs]</a><span class="k">class</span> <span class="nc">SimpleDataTransformationTemplateNode</span><span class="p">(</span><span class="n">BaseNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Parametrized algorithm, transforming the data without training</span>

<span class="sd">    Describe your algorithm in detail.</span>

<span class="sd">    In the simplest case, an algorithm only implements its initialization</span>
<span class="sd">    and execution function like this node.</span>

<span class="sd">    The list of parameters should always be complete and correct to avoid</span>
<span class="sd">    hidden functionality.</span>

<span class="sd">    **References**</span>

<span class="sd">        If this node is using code from other implementations or</span>
<span class="sd">        is described in detail in a publication,</span>
<span class="sd">        mention the reference here.</span>

<span class="sd">    **Parameters**</span>
<span class="sd">        :Parameter1: Describe effect and specialties</span>

<span class="sd">            (*recommended, default: 42*)</span>

<span class="sd">        :Parameter2: Describe the effect, and if something special happens by</span>
<span class="sd">            default. It is also important to mention, which entries are possible</span>
<span class="sd">            (e.g. only True and False are accepted values).</span>

<span class="sd">            (*optional, default: False*)</span>

<span class="sd">    **Exemplary Call**</span>

<span class="sd">    .. code-block:: yaml</span>

<span class="sd">        -</span>
<span class="sd">            node : SimpleDataTransformationTemplate</span>
<span class="sd">            parameters:</span>
<span class="sd">                Parameter1 : 77</span>
<span class="sd">                Parameter2 : False</span>


<span class="sd">    :input:    Type1 (e.g. FeatureVector)</span>
<span class="sd">    :output:   Type2 (e.g. FeatureVector)</span>
<span class="sd">    :Author: Mario Muster (muster@informatik.exelent-university.de)</span>
<span class="sd">    :Created: 2013/02/25</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SimpleDataTransformationTemplateNode.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleDataTransformationTemplateNode.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Parameter1</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">Parameter2</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the basic parameters special for this algorithm</span>

<span class="sd">        If your init is not doing anything special, it does not need any</span>
<span class="sd">        documentation. The relevant class documentation</span>
<span class="sd">        is expected to be in the class docstring.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The mapping from the call of the function with a YAML file</span>
<span class="sd">            and this init is totally straightforward.</span>
<span class="sd">            Every parameter in the dictionary description in the</span>
<span class="sd">            YAML file is directly used at the init call.</span>
<span class="sd">            The value of the parameter is transformed with the help</span>
<span class="sd">            of the YAML syntax (see: :ref:`yaml`).</span>

<span class="sd">        It is important to also use `**kwargs`, because they have to be</span>
<span class="sd">        forwarded to the base class, using:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            super(SimpleDataTransformationTemplateNode, self).__init__(**kwargs)</span>

<span class="sd">        .. warning::</span>
<span class="sd">            With the call of `super` comes some hidden functionality.</span>
<span class="sd">            Every self parameter in the init is made permanent via the</span>
<span class="sd">            function:</span>
<span class="sd">            :func:`~pySPACE.missions.nodes.base_node.BaseNode.set_permanent_attributes`</span>
<span class="sd">            from the base node.</span>
<span class="sd">            Normally all self parameters are instantiated after this call</span>
<span class="sd">            and have to be made permanent on their own.</span>
<span class="sd">            Permanent means, that these parameters are reset to the</span>
<span class="sd">            defined value, when the</span>
<span class="sd">            :func:`~pySPACE.missions.nodes.base_node.BaseNode.reset`</span>
<span class="sd">            method is called.</span>
<span class="sd">            This is for example done during k-fold cross validation, when</span>
<span class="sd">            the training fold is changed.</span>
<span class="sd">            For special variable types you may run into trouble,</span>
<span class="sd">            because set_permanent_attributes needs to copy them.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            The init function is called before the distribution of node_chains</span>
<span class="sd">            in the parallel execution. So the node parameters need to be</span>
<span class="sd">            able to be stored into the pickle format.</span>
<span class="sd">            If you need parameters, which have not this functionality,</span>
<span class="sd">            just initialize them with the first call of the training or execute</span>
<span class="sd">            method.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            self.set_permanent_attributes(  P1 : Parameter1,</span>
<span class="sd">                                            P2 : Parameter2,</span>
<span class="sd">                                            P3 : &quot;Hello&quot;</span>
<span class="sd">                                         )</span>

<span class="sd">        Here `self.P3` will be an internal parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SimpleDataTransformationTemplateNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">Parameter1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Parameter 1 is having wrong type </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Parameter1</span><span class="p">)))</span>
            <span class="n">Parameter1</span> <span class="o">=</span> <span class="mi">42</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">P1</span><span class="o">=</span><span class="n">Parameter1</span><span class="p">,</span>
                                      <span class="n">P2</span><span class="o">=</span><span class="n">Parameter2</span><span class="p">,</span>
                                      <span class="n">P3</span><span class="o">=</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SimpleDataTransformationTemplateNode._execute"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SimpleDataTransformationTemplateNode._execute">[docs]</a>    <span class="k">def</span> <span class="nf">_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; General description of algorithm maybe followed by further details</span>

<span class="sd">        E.g. log &quot;Hello&quot; during first call and if P2 is set to True,</span>
<span class="sd">        always multiply data with P1 and in the other case forward the data.</span>

<span class="sd">        Logging is done using</span>
<span class="sd">        :func:`~pySPACE.missions.nodes.base_node.BaseNode._log`:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            self._log(self.P3, level=logging.DEBUG)</span>

<span class="sd">        To access only the data array and not the attached meta data, use</span>
<span class="sd">        `data = x.view(numpy.ndarray)` for preparation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">P3</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P3</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P2</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P1</span> <span class="o">*</span> <span class="n">data</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">FeatureVector</span><span class="o">.</span><span class="n">replace_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

</div></div>
<div class="viewcode-block" id="TrainableAlgorithmTemplateNode"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode">[docs]</a><span class="k">class</span> <span class="nc">TrainableAlgorithmTemplateNode</span><span class="p">(</span><span class="n">SimpleDataTransformationTemplateNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Template for trainable algorithms</span>

<span class="sd">    :class:`SimpleDataTransformationTemplateNode` is the base node for this node</span>
<span class="sd">    and so, this node does not have to implement an _execute or __init__</span>
<span class="sd">    function. Often these methods have to be implemented nevertheless,</span>
<span class="sd">    but not here, to keep the example short.</span>

<span class="sd">    For trainable methods, a minimum of two functions has to be implemented:</span>
<span class="sd">    :func:`is_trainable` and :func:`_train`.</span>
<span class="sd">    Optionally four other functions can be overwritten:</span>
<span class="sd">    :func:`is_supervised`, :func:`_stop_training`, :func:`_inc_train`</span>
<span class="sd">    and :func:`start_retraining.`</span>
<span class="sd">    The first returns by default `False` and the other methods do nothing.</span>

<span class="sd">    .. note:: The execute function is applied on all data,</span>
<span class="sd">              even the training data, but the true label remains unknown.</span>

<span class="sd">    **Parameters**</span>
<span class="sd">        Please refer to :class:`SimpleDataTransformationTemplateNode`</span>

<span class="sd">        .. note:: Parameter1 is determined, by counting the training examples.</span>

<span class="sd">    **Exemplary Call**</span>

<span class="sd">    .. code-block:: yaml</span>

<span class="sd">        -</span>
<span class="sd">            node : TrainableAlgorithmTemplateNode</span>
<span class="sd">            parameters:</span>
<span class="sd">                Parameter1 : 77</span>
<span class="sd">                Parameter2 : False</span>

<span class="sd">    :input:    Type1 (e.g. FeatureVector)</span>
<span class="sd">    :output:   Type2 (e.g. FeatureVector)</span>
<span class="sd">    :Author: Mario Muster (muster@informatik.exelent-university.de)</span>
<span class="sd">    :Created: 2013/02/25</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TrainableAlgorithmTemplateNode.is_trainable"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode.is_trainable">[docs]</a>    <span class="k">def</span> <span class="nf">is_trainable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Define trainable node, by returning True in this function &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="TrainableAlgorithmTemplateNode.is_supervised"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode.is_supervised">[docs]</a>    <span class="k">def</span> <span class="nf">is_supervised</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return True to get access to labels in training functions &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="TrainableAlgorithmTemplateNode._train"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode._train">[docs]</a>    <span class="k">def</span> <span class="nf">_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">class_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Called for each element in training data to be processed</span>

<span class="sd">        Incremental algorithms, simply use the example to change their</span>
<span class="sd">        parameters and batch algorithms preprocess data and only store it.</span>

<span class="sd">        If :func:`is_supervised` were not overwritten or set `False`,</span>
<span class="sd">        this function is defined without the parameter *class_label*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P3</span> <span class="o">==</span> <span class="s">&quot;Hello&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P3</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P1</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P3</span> <span class="o">+=</span> <span class="n">class_label</span>
</div>
<div class="viewcode-block" id="TrainableAlgorithmTemplateNode._stop_training"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode._stop_training">[docs]</a>    <span class="k">def</span> <span class="nf">_stop_training</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Called after processing of all training examples</span>

<span class="sd">        For simplicity, we just reimplement the default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="TrainableAlgorithmTemplateNode._inc_train"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode._inc_train">[docs]</a>    <span class="k">def</span> <span class="nf">_inc_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span> <span class="n">class_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Train on new examples in testing phase</span>

<span class="sd">        During testing phase in the application phase,</span>
<span class="sd">        new labeled examples may occur  and this function is</span>
<span class="sd">        used to improve the already trained algorithm on these examples.</span>

<span class="sd">        .. note:: This method should always be as fast as possible.</span>

<span class="sd">        For simplicity, we only forward everything to :func:`_train`.</span>

<span class="sd">        For more details on retraining (how to turn it on, and how it works),</span>
<span class="sd">        have a look at the documentation of the *retrain* parameter</span>
<span class="sd">        in the :class:`~pySPACE.missions.nodes.base_node.BaseNode`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">class_label</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TrainableAlgorithmTemplateNode.start_retraining"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.TrainableAlgorithmTemplateNode.start_retraining">[docs]</a>    <span class="k">def</span> <span class="nf">start_retraining</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Prepare retraining</span>

<span class="sd">        Normally this method is not needed and does nothing,</span>
<span class="sd">        but maybe some parameters</span>
<span class="sd">        have to be changed, before the first retraining with</span>
<span class="sd">        the _inc_train method should be done.</span>
<span class="sd">        This method is here, to give this possibility.</span>

<span class="sd">        In our case, we simply reset the starting parameter *self.P3*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P3</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>

</div></div>
<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate">[docs]</a><span class="k">class</span> <span class="nc">SpecialPurposeFunctionsTemplate</span><span class="p">(</span><span class="n">BaseNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Introduce additional available functions</span>

<span class="sd">    Additional to the aforementioned methods,</span>
<span class="sd">    some algorithms have to overwrite the default behavior of nodes,</span>
<span class="sd">    directly change the normal data flow,</span>
<span class="sd">    manipulate data or labels,</span>
<span class="sd">    or communicate information to other nodes.</span>

<span class="sd">    Some of these methods will be introduced in the following and some use cases</span>
<span class="sd">    will be given.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Every method in the :class:`~pySPACE.missions.nodes.base_node.BaseNode`</span>
<span class="sd">        could be overwritten but this should be done very carefully to avoid</span>
<span class="sd">        bad side effects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.store_state"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.store_state">[docs]</a>    <span class="k">def</span> <span class="nf">store_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result_dir</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Store some additional results or information of this node</span>

<span class="sd">        Here the parameter *self.store* should be used to switch on the saving,</span>
<span class="sd">        since this method is called in every case,</span>
<span class="sd">        but should only store information, if this parameter is set true</span>

<span class="sd">        This method is automatically called during benchmarking</span>
<span class="sd">        for every node.</span>
<span class="sd">        It is for example used</span>
<span class="sd">        to store visualization of algorithms or data.</span>

<span class="sd">        Additionally to the result_dir, the node name should be used.</span>
<span class="sd">        If you expect this node to occur multiple times in a node chain,</span>
<span class="sd">        also use the index. This can be done for example like:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            import os</span>
<span class="sd">            from pySPACE.tools.filesystem import create_directory</span>
<span class="sd">            if self.store:</span>
<span class="sd">                #set the specific directory for this particular node</span>
<span class="sd">                node_dir = os.path.join(result_dir, self.__class__.__name__)</span>
<span class="sd">                #do we have an index-number?</span>
<span class="sd">                if index is None:</span>
<span class="sd">                    #add the index-number...</span>
<span class="sd">                    node_dir += &quot;_%d&quot; % int(index)</span>
<span class="sd">                create_directory(node_dir)</span>

<span class="sd">        Furthermore, it is very important to integrate the split number into</span>
<span class="sd">        the file name when storing, because otherwise your results will be</span>
<span class="sd">        overwritten. The convention in pySPACE is, to have a meaningful name</span>
<span class="sd">        of the part of the node you store followed by an underscore and &#39;sp&#39;</span>
<span class="sd">        and the split number as done in</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            file_name = &quot;%s_sp%s.pickle&quot; % (&quot;patterns&quot;, self.current_split)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.reset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Resets the node to a clean state</span>

<span class="sd">        Every parameter set with</span>
<span class="sd">        :func:`~pySPACE.missions.nodes.base_node.BaseNode.set_permanent_attributes`</span>
<span class="sd">        is by default reset here to its specified value or deleted,</span>
<span class="sd">        if no value is specified.</span>

<span class="sd">        Since this method copies every parameter or some variables escape</span>
<span class="sd">        from the normal class variables scope, some methods need to overwrite</span>
<span class="sd">        this method.</span>

<span class="sd">        When you really need to overwrite this method some points have to be</span>
<span class="sd">        considered. For the normal functionality of the node, the super method</span>
<span class="sd">        needs to be called. To avoid deleting of the special variables,</span>
<span class="sd">        they have to be made local variables beforehand and afterwards again</span>
<span class="sd">        cast to class variables. This is depicted in the following example code,</span>
<span class="sd">        taken from the</span>
<span class="sd">        :class:`~pySPACE.missions.nodes.meta.same_input_layer.SameInputLayerNode`.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            def reset(self):</span>
<span class="sd">                &#39;&#39;&#39; Also reset internal nodes &#39;&#39;&#39;</span>
<span class="sd">                nodes = self.nodes</span>
<span class="sd">                for node in nodes:</span>
<span class="sd">                    node.reset()</span>
<span class="sd">                super(SameInputLayerNode, self).reset()</span>
<span class="sd">                self.nodes = nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.get_result_dataset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.get_result_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">get_result_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Implementing this function, makes a node a :mod:`~pySPACE.missions.nodes.sink` &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.request_data_for_training"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.request_data_for_training">[docs]</a>    <span class="k">def</span> <span class="nf">request_data_for_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_test_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns generator for training data for subsequent nodes of the node chain</span>

<span class="sd">        If *use_test_data* is true, all available data is used for</span>
<span class="sd">        training, otherwise only the data that is explicitly for training.</span>

<span class="sd">        These methods normally use the</span>
<span class="sd">        :class:`~pySPACE.tools.memoize_generator.MemoizeGenerator`</span>
<span class="sd">        to define their generator.</span>
<span class="sd">        When implementing such a method, one should always try not to double</span>
<span class="sd">        data but only redirect it, without extra storing it.</span>

<span class="sd">        The definition or redefinition of training data is done</span>
<span class="sd">        by :mod:`~pySPACE.missions.nodes.source` and</span>
<span class="sd">        :mod:`~pySPACE.missions.nodes.splitter` nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.request_data_for_testing"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.request_data_for_testing">[docs]</a>    <span class="k">def</span> <span class="nf">request_data_for_testing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns data for testing of subsequent nodes of the node chain</span>

<span class="sd">        When defining :func:`request_data_for_training` this method</span>
<span class="sd">        normally has to be</span>
<span class="sd">        implemented/overwritten, too and vice versa.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.process_current_split"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.process_current_split">[docs]</a>    <span class="k">def</span> <span class="nf">process_current_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Main processing part on test and training data of current split</span>

<span class="sd">        This method is called in the usage with benchmark node chains</span>
<span class="sd">        and defines the gathering of the result data of the node chain</span>
<span class="sd">        for a :mod:`~pySPACE.missions.nodes.sink` node.</span>

<span class="sd">        Hereby it gets the data by calling</span>
<span class="sd">        :func:`request_data_for_training` and :func:`request_data_for_testing`.</span>

<span class="sd">        In the case of using the</span>
<span class="sd">        :class:`~pySPACE.missions.nodes.cv_splitter.CrossValidationSplitterNode`,</span>
<span class="sd">        this method is called multiple times</span>
<span class="sd">        for each split and stores every time the result in the result dataset</span>
<span class="sd">        separately.</span>

<span class="sd">        Though this approach seems on first sight very complicated on first</span>
<span class="sd">        sight, it gives three very strong advantages.</span>

<span class="sd">        * The cross validation can be done exactly before the first trainable</span>
<span class="sd">          node in the node chain and circumvents unnecessary double processing.</span>

<span class="sd">        * By handling indices instead of real data,</span>
<span class="sd">          the data for training and testing is not copied and memory is saved.</span>

<span class="sd">        * The cross validation is very easy to use.</span>
<span class="sd">          Moving this functionality to the</span>
<span class="sd">          :mod:`~pySPACE.resources.dataset_types`</span>
<span class="sd">          would make the usage muh mor complicated and inefficient.</span>
<span class="sd">          Especially for nodes, which internally use node chains,</span>
<span class="sd">          like the :mod:`~pySPACE.missions.nodes.meta.parameter_optimization`</span>
<span class="sd">          nodes, this easy access pays off.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="SpecialPurposeFunctionsTemplate.get_sensor_ranking"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.templates.html#pySPACE.missions.nodes.templates.SpecialPurposeFunctionsTemplate.get_sensor_ranking">[docs]</a>    <span class="k">def</span> <span class="nf">get_sensor_ranking</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return sensor ranking fitting to the algorithm</span>

<span class="sd">        For usage with the ranking variant in the</span>
<span class="sd">        :class:`~pySPACE.missions.nodes.spatial_filtering.sensor_selection.SensorSelectionRankingNode`</span>
<span class="sd">        this method of the node is called to get the ranking to reduce sensors.</span>

<span class="sd">        The ranking is a sorted list of tuple (sensor name, weight).</span>
<span class="sd">        The first element has to correspond to the</span>
<span class="sd">        sensor with the lowest weight, meaning it is the most unimportant.</span>

<span class="sd">        .. note:: The code here is a copy from</span>
<span class="sd">            :class:`~pySPACE.missions.nodes.classification.base`</span>
<span class="sd">            which takes the classification vector `self.features`</span>
<span class="sd">            and sums up the absolute values fitting to one channel.</span>
<span class="sd">            It is only used as an example.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># channel name is what comes after the first underscore</span>
        <span class="n">feat_channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">chnames</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                              <span class="k">for</span> <span class="n">chnames</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">feature_names</span><span class="p">]</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
        <span class="n">ranking_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">ranking_dict</span><span class="p">[</span><span class="n">feat_channel_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ranking</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ranking_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ranking</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">pySPACE 0.5 alpha documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, pySPACE Developer Team.
      Last updated on Aug 07, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>