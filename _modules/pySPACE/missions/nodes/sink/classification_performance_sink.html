

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pySPACE.missions.nodes.sink.classification_performance_sink &mdash; pySPACE 0.5 alpha documentation</title>
    
    <link rel="stylesheet" href="../../../../../_static/pySPACE.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../',
        VERSION:     '0.5 alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../../_static/pyspace-logo.ico"/>
    <link rel="top" title="pySPACE 0.5 alpha documentation" href="../../../../../index.html" />
    <link rel="up" title="Module code" href="../../../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../../index.html">pySPACE 0.5 alpha documentation</a> &raquo;</li>
          <li><a href="../../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../../index.html">
              <img class="logo" src="../../../../../_static/pyspace-logo_small.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pySPACE.missions.nodes.sink.classification_performance_sink</h1><div class="highlight"><pre>
<span class="c"># This Python file uses the following encoding: utf-8</span>
<span class="c"># The upper line is needed for one comment in this module.</span>
<span class="sd">&quot;&quot;&quot; Calculate performance measures from classification results and store them</span>

<span class="sd">All performance sink nodes interface to the</span>
<span class="sd">:mod:`~pySPACE.resources.dataset_defs.metric` datasets, where the final metric values .</span>
<span class="sd">are calculated.</span>

<span class="sd">These results can be put together using the</span>
<span class="sd">:class:`~pySPACE.resources.dataset_defs.performance_result.PerformanceResultSummary`.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">cPickle</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">timeit</span>

<span class="kn">from</span> <span class="nn">pySPACE.missions.nodes.base_node</span> <span class="kn">import</span> <span class="n">BaseNode</span>
<span class="kn">from</span> <span class="nn">pySPACE.tools.filesystem</span> <span class="kn">import</span> <span class="n">create_directory</span>
<span class="kn">from</span> <span class="nn">pySPACE.resources.dataset_defs.metric</span> <span class="kn">import</span> <span class="n">metricdict</span><span class="p">,</span> \
                                            <span class="n">BinaryClassificationDataset</span><span class="p">,</span> \
                                            <span class="n">MultinomialClassificationDataset</span><span class="p">,</span>\
                                            <span class="n">RegressionDataset</span>

<span class="kn">import</span> <span class="nn">logging</span>

<div class="viewcode-block" id="PerformanceSinkNode"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode">[docs]</a><span class="k">class</span> <span class="nc">PerformanceSinkNode</span><span class="p">(</span><span class="n">BaseNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate performance measures from standard prediction vectors and store them</span>
<span class="sd">    </span>
<span class="sd">    It takes all classification vectors that are passed on to it</span>
<span class="sd">    from a continuous classifier, calculates the performance measures and</span>
<span class="sd">    stores them. The results can be later on collected and merged</span>
<span class="sd">    into one tabular with the</span>
<span class="sd">    :class:`~pySPACE.missions.operations.node_chain.NodeChainOperation`.</span>
<span class="sd">    This one can be read manually or it can be</span>
<span class="sd">    visualized with a gui.</span>

<span class="sd">    .. note:: FeatureVectorSinkNode was the initial model of this node.</span>
<span class="sd">    </span>
<span class="sd">    **Parameters**</span>
<span class="sd">        :type:</span>
<span class="sd">            Define type of incoming results to be processed.</span>
<span class="sd">            Currently ``binary``</span>
<span class="sd">            (:class:`~pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset`)</span>
<span class="sd">            and ``multinomial``</span>
<span class="sd">            (:class:`~pySPACE.resources.dataset_defs.metric.MultinomialClassificationDataset`)</span>
<span class="sd">            classification and ``regression`` (even for n-dimensional output)</span>
<span class="sd">            (:class:`~pySPACE.resources.dataset_defs.metric.RegressionDataset`)</span>
<span class="sd">            metrics can be calculated.</span>

<span class="sd">            For the multinomial and regression case</span>
<span class="sd">            several parameters are not yet important.</span>
<span class="sd">            These are:</span>

<span class="sd">                * ir_class</span>
<span class="sd">                * save_roc_points</span>
<span class="sd">                * calc_AUC</span>
<span class="sd">                * calc_soft_metrics</span>
<span class="sd">                * calc_loss</span>
<span class="sd">                * sum_up_splits</span>

<span class="sd">            .. warning:: Multinomial classification and regression have not yet</span>
<span class="sd">                         been used often enough with pySPACE and require</span>
<span class="sd">                         additional testing.</span>

<span class="sd">            (*optional, default: &quot;binary&quot;*)</span>

<span class="sd">        :ir_class:</span>
<span class="sd">            The class name (as string) for which IR statistics are to be output.</span>
<span class="sd">            </span>
<span class="sd">            (*recommended, default: &#39;Target&#39;*)</span>

<span class="sd">        :save_individual_classifications:</span>
<span class="sd">            If True, for every processed split a pickle file will be generated</span>
<span class="sd">            that contains the numerical classification result (cresult) for every</span>
<span class="sd">            individual window along with the estimated class label (c_est), the</span>
<span class="sd">            true class label (c_true) and the number of features used (nr_feat).</span>
<span class="sd">            The result is a list whose elements correspond to a single window and</span>
<span class="sd">            have the following shape:</span>
<span class="sd">            ::</span>
<span class="sd">            </span>
<span class="sd">                [ [c_est, cresult, nr_feat], c_true ]</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: False*)</span>

<span class="sd">        :save_roc_points:</span>
<span class="sd">            If True, for every processed split a pickle file will be generated</span>
<span class="sd">            that contains a list of tuples (=points) increasing by FP rate, that</span>
<span class="sd">            can be used to plot a Receiver Operator Curve (ROC) and a list, that</span>
<span class="sd">            contains the actually used point in the ROC space together with (0|0)</span>
<span class="sd">            and (1|1). The result has the following shape:</span>
<span class="sd">            ::</span>
<span class="sd">            </span>
<span class="sd">                ( [(fp_rate_1,tp_rate_1), ... ,(fp_rate_n,tp_rate_n)],</span>
<span class="sd">                  [(0.0,0.0), (fp_rate, tp_rate), (1.0,1.0)])</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: False*)</span>

<span class="sd">        :weight:</span>
<span class="sd">            weight is the weight for the weighted accuracy. For many scenarios</span>
<span class="sd">            a relevant performance measure is a combination of</span>
<span class="sd">            True-Positive-Rate (TPR) and True-Negative-Rate (TNR), where one of the</span>
<span class="sd">            two might be of higher importance than the other, and thus gets a</span>
<span class="sd">            higher weight. Essentially, the weighted accuracy is</span>
<span class="sd">            calculated by</span>
<span class="sd">            </span>
<span class="sd">            .. math:: \\text{Weighted\_accuracy} = weight \\cdot TPR + (1 - weight) \\cdot TNR</span>
<span class="sd">            </span>
<span class="sd">            If this parameter is not set, the value equals the balanced accuracy.</span>
<span class="sd">            In the case of `multinomial` classification, this parameter</span>
<span class="sd">            has to be a dictionary.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: 0.5*)</span>
<span class="sd">            </span>
<span class="sd">        :measure_times:</span>
<span class="sd">            measure the average and maximum time that is needed for the processing </span>
<span class="sd">            of the data between the last sink node in the nod chain and this node.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: True*)</span>

<span class="sd">        :calc_soft_metrics:</span>
<span class="sd">            integrate uncertainty of classifier into metric</span>
<span class="sd">            prediction value is projected to interval [-1,1]</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: False*)</span>

<span class="sd">        :calc_train:</span>
<span class="sd">            Switch for calculating metrics on the training data</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: True*)</span>

<span class="sd">        :calc_AUC:</span>
<span class="sd">            Calculate the AUC metric</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: True*)</span>

<span class="sd">        :calc_loss:</span>
<span class="sd">            Integrates the calculated losses into the final csv-file.</span>
<span class="sd">            (L1, L2), (LDA, SVM, RMM), (restricted, unrestricted) </span>
<span class="sd">            and (equal weighted, *balanced*) losses are</span>
<span class="sd">            calculated in all combinations, resulting in 24 entries.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: True*)</span>

<span class="sd">            :loss_restriction:</span>
<span class="sd">                Maximum value of the single loss values.</span>
<span class="sd">                Everything above is reduced to the maximum.</span>

<span class="sd">                (*optional, default: 2*)</span>

<span class="sd">        :sum_up_splits:</span>
<span class="sd">            If you use a CV-Splitter in your node chain, the performance sink adds up</span>
<span class="sd">            the basic metrics and calculates confusion matrix metrics with these </span>
<span class="sd">            values. The other metrics are averaged.</span>
<span class="sd">            So a lot of more testing examples are relevant for the calculation.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: False*)</span>
<span class="sd">            </span>
<span class="sd">        :dataset_pattern:</span>
<span class="sd">            If the __Dataset__ is of the form &quot;X_Y_Z&quot;, then this pattern can be</span>
<span class="sd">            specified with this parameter. The different values X, Y, Z will then</span>
<span class="sd">            appear in corresponding columns in the results.csv. Example: If the</span>
<span class="sd">            datasets are of the form &quot;NJ89_20111128_3&quot;, and one passes the</span>
<span class="sd">            dataset_pattern &quot;subject_date_setNr&quot;, then the results.csv will have</span>
<span class="sd">            the columns __Subject__, __Date__ and __SetNr__ with the corresponding</span>
<span class="sd">            values parsed (note the added underscores and capitalized first letter).</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: None*)</span>
<span class="sd">            </span>
<span class="sd">        :decision_boundary:</span>
<span class="sd">            If your decision boundary is not at zero you should specify this for</span>
<span class="sd">            the calculation of metrics depending on the prediction values.</span>
<span class="sd">            Probabilistic classifiers often have a boundary at 0.5. </span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: 0.0*)</span>
<span class="sd">        </span>
<span class="sd">        :save_trace:</span>
<span class="sd">            Generates a table which contains a confusion matrix over time/samples.</span>
<span class="sd">            There are two types of traces: short traces and long traces. </span>
<span class="sd">            The short traces contain only the information, if a classification</span>
<span class="sd">            was a TP, TN, FP or FN. The long traces contain may furthermore contain</span>
<span class="sd">            loss values and are saved as a dictionary.</span>
<span class="sd">            To save only short traces (for, e.g. performance reasons), set save_trace</span>
<span class="sd">            to ``short``. To save long and short traces, set save_trace to True.    </span>

<span class="sd">            (*optional, default: False*)</span>
<span class="sd">            </span>
<span class="sd">    **Exemplary Call**</span>

<span class="sd">    .. code-block:: yaml</span>

<span class="sd">        -  </span>
<span class="sd">            node : Classification_Performance_Sink</span>
<span class="sd">            parameters :</span>
<span class="sd">                ir_class : &quot;Target&quot;</span>
<span class="sd">                weight : 0.5</span>

<span class="sd">    :input:  PredictionVector</span>
<span class="sd">    :output: ClassificationDataset</span>
<span class="sd">    :Author: Mario Krell (mario.krell@dfki.de)</span>
<span class="sd">    :Created: 2012/08/02</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PerformanceSinkNode.__init__"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classes_names</span><span class="o">=</span><span class="p">[],</span> <span class="n">ir_class</span><span class="o">=</span><span class="s">&quot;Target&quot;</span><span class="p">,</span>
                 <span class="n">save_individual_classifications</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">save_roc_points</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">measure_times</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">sum_up_splits</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dataset_pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">calc_AUC</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">calc_loss</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">calc_train</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">save_trace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">decision_boundary</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">loss_restriction</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="nb">type</span><span class="o">=</span><span class="s">&quot;binary&quot;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PerformanceSinkNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_roc_points</span><span class="p">:</span>
            <span class="n">calc_AUC</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s">&quot;multinomial&quot;</span> <span class="ow">or</span> <span class="nb">type</span> <span class="o">==</span> <span class="s">&quot;multiclass&quot;</span><span class="p">:</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="s">&quot;multinomial&quot;</span>
            <span class="n">save_trace</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">save_roc_points</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">calc_AUC</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">calc_loss</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">calc_soft_metrics</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">sum_up_splits</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">MultinomialClassificationDataset</span><span class="p">(</span><span class="n">dataset_pattern</span><span class="o">=</span>
                                                  <span class="n">dataset_pattern</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s">&quot;binary&quot;</span><span class="p">:</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">BinaryClassificationDataset</span><span class="p">(</span><span class="n">dataset_pattern</span><span class="o">=</span><span class="n">dataset_pattern</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s">&quot;regression&quot;</span><span class="p">:</span>
            <span class="n">save_trace</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">save_roc_points</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">calc_AUC</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">calc_loss</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">calc_soft_metrics</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">sum_up_splits</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">RegressionDataset</span><span class="p">(</span><span class="n">dataset_pattern</span><span class="o">=</span><span class="n">dataset_pattern</span><span class="p">)</span>

        <span class="n">store</span> <span class="o">=</span> \
            <span class="n">save_individual_classifications</span> <span class="ow">or</span> \
            <span class="n">save_roc_points</span> <span class="ow">or</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="ow">or</span> \
            <span class="n">save_trace</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span>
                <span class="n">ir_class</span><span class="o">=</span><span class="n">ir_class</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span>
                <span class="n">classification_dataset</span><span class="o">=</span><span class="n">cc</span><span class="p">,</span>
                <span class="n">classes_names</span><span class="o">=</span><span class="n">classes_names</span><span class="p">,</span>
                <span class="n">sec_class</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>  <span class="c"># determined later on for checks in binary classification</span>
                <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                <span class="n">save_individual_classifications</span><span class="o">=</span><span class="n">save_individual_classifications</span><span class="p">,</span>
                <span class="n">save_roc_points</span><span class="o">=</span><span class="n">save_roc_points</span><span class="p">,</span>
                <span class="n">measure_times</span><span class="o">=</span><span class="n">measure_times</span><span class="p">,</span>
                <span class="n">calc_soft_metrics</span><span class="o">=</span><span class="n">calc_soft_metrics</span><span class="p">,</span>
                <span class="n">example</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">sum_up_splits</span><span class="o">=</span><span class="n">sum_up_splits</span><span class="p">,</span>
                <span class="n">calc_AUC</span><span class="o">=</span><span class="n">calc_AUC</span><span class="p">,</span>
                <span class="n">calc_loss</span><span class="o">=</span><span class="n">calc_loss</span><span class="p">,</span>
                <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">,</span>
                <span class="n">loss_restriction</span><span class="o">=</span><span class="n">loss_restriction</span><span class="p">,</span>
                <span class="n">calc_train</span><span class="o">=</span><span class="n">calc_train</span><span class="p">,</span>
                <span class="n">save_trace</span><span class="o">=</span><span class="n">save_trace</span><span class="p">,</span>
                <span class="n">store</span><span class="o">=</span><span class="n">store</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
                <span class="n">invert_classification</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PerformanceSinkNode.reset"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; classification_dataset has to be kept over all splits &quot;&quot;&quot;</span>
        <span class="c"># We have to create a temporary reference since we remove </span>
        <span class="c"># the self.permanent_state reference in the next step by overwriting</span>
        <span class="c"># self.__dict__</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span>
        <span class="c"># reset should not delete classification dataset</span>
        <span class="c"># if you want to delete the dataset just do it explicitly.</span>
        <span class="n">tmp</span><span class="p">[</span><span class="s">&quot;classification_dataset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span> <span class="o">=</span> <span class="n">tmp</span>
</div>
<div class="viewcode-block" id="PerformanceSinkNode.is_trainable"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode.is_trainable">[docs]</a>    <span class="k">def</span> <span class="nf">is_trainable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return whether this node is trainable. </span>

<span class="sd">        .. todo:: Check if return should be False and edit documentation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Though this node is not really trainable, it returns true in order</span>
        <span class="c"># to request the training data from previous notes.</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="PerformanceSinkNode.is_supervised"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode.is_supervised">[docs]</a>    <span class="k">def</span> <span class="nf">is_supervised</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return whether this node requires supervised training. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="PerformanceSinkNode._execute"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode._execute">[docs]</a>    <span class="k">def</span> <span class="nf">_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c"># We simply pass the given data on to the next node</span>
        <span class="k">return</span> <span class="n">data</span>
</div>
<div class="viewcode-block" id="PerformanceSinkNode._train"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode._train">[docs]</a>    <span class="k">def</span> <span class="nf">_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="c"># We simply pass the given data on to the next node</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span>
</div>
<div class="viewcode-block" id="PerformanceSinkNode.process_current_split"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode.process_current_split">[docs]</a>    <span class="k">def</span> <span class="nf">process_current_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Main processing part on test and training data of current split</span>
<span class="sd">        </span>
<span class="sd">        Performance metrics are calculated for training and test data separately.</span>
<span class="sd">        Metrics on training data help to detect errors in classifier construction</span>
<span class="sd">        and to compare in how far it behaves the same way as on testing data.</span>
<span class="sd">        </span>
<span class="sd">        The function only collects the data, measures execution times </span>
<span class="sd">        and calls functions to update confusion matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">################</span>
        <span class="c">### TRAINING ###</span>
        <span class="c">################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Processing training data&quot;</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="n">start_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> \
                                   <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">request_data_for_training</span><span class="p">(</span><span class="bp">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">label</span><span class="o">==</span><span class="s">&#39;REST&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_helper_parameters</span><span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="n">stop_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">training_time</span> <span class="o">=</span> <span class="n">stop_time_stamp</span> <span class="o">-</span> <span class="n">start_time_stamp</span>



        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">==</span><span class="s">&quot;binary&quot;</span> \
                            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="o">==</span><span class="p">[]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span><span class="n">node_name</span> <span class="ow">in</span> \
                    <span class="p">[</span><span class="s">&quot;PlattsSigmoidFitNode&quot;</span><span class="p">,</span>
                     <span class="s">&quot;LinearFitNode&quot;</span><span class="p">,</span>
                     <span class="s">&quot;SigmoidTransformationNode&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="o">=</span><span class="mf">0.5</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">train_result</span> <span class="o">=</span> <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span>
                <span class="n">classification_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="p">,</span>
                <span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_soft_metrics</span><span class="p">,</span>
                <span class="n">invert_classification</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">invert_classification</span><span class="p">,</span>
                <span class="n">ir_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ir_class</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sec_class</span><span class="p">,</span>
                <span class="n">loss_restriction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_restriction</span><span class="p">,</span>
                <span class="n">time_periods</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">calc_AUC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_AUC</span><span class="p">,</span><span class="n">calc_loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_loss</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span><span class="n">save_roc_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_roc_points</span><span class="p">,</span>
                <span class="n">decision_boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">train_metrics</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">train_R</span> <span class="o">=</span> <span class="n">train_result</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">train_metrics</span> <span class="o">=</span> <span class="n">train_result</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&quot;multinomial&quot;</span><span class="p">:</span>
            <span class="n">train_metrics</span> <span class="o">=</span> <span class="n">MultinomialClassificationDataset</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span>
                        <span class="n">classification_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="p">,</span>
                        <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&quot;regression&quot;</span><span class="p">:</span>
            <span class="n">train_metrics</span> <span class="o">=</span> <span class="n">RegressionDataset</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span>
                <span class="n">regression_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="p">:</span>
            <span class="n">train_metrics</span> <span class="o">=</span> <span class="n">metricdict</span><span class="p">()</span>
        <span class="c">###############</span>
        <span class="c">### TESTING ###</span>
        <span class="c">###############</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Processing testing data&quot;</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
        <span class="c"># for saving the actual numerical classification results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># class\guess ir sec</span>
        <span class="c"># ir_class:   TP FN</span>
        <span class="c"># sec_class:  FP TN</span>
        
        <span class="c"># initialization to measure execution speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_periods</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_periods</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">start_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">example</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> \
                                   <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">request_data_for_testing</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
                <span class="n">stop_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_periods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stop_time_stamp</span> <span class="o">-</span> <span class="n">start_time_stamp</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="o">==</span><span class="s">&#39;REST&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_helper_parameters</span><span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
            <span class="c"># re-initialization of time before next item is requested</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
                <span class="n">start_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> \
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span><span class="n">node_name</span> <span class="ow">in</span> \
                <span class="p">[</span><span class="s">&quot;PlattsSigmoidFitNode&quot;</span><span class="p">,</span>
                 <span class="s">&quot;LinearFitNode&quot;</span><span class="p">,</span>
                 <span class="s">&quot;SigmoidTransformationNode&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="o">=</span><span class="mf">0.5</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">==</span><span class="s">&quot;binary&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span>
                        <span class="n">classification_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">,</span>
                        <span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_soft_metrics</span><span class="p">,</span>
                        <span class="n">invert_classification</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">invert_classification</span><span class="p">,</span>
                        <span class="n">ir_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ir_class</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sec_class</span><span class="p">,</span>
                        <span class="n">loss_restriction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_restriction</span><span class="p">,</span>
                        <span class="n">time_periods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_periods</span><span class="p">,</span>
                        <span class="n">calc_AUC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_AUC</span><span class="p">,</span><span class="n">calc_loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_loss</span><span class="p">,</span>
                        <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span><span class="n">save_roc_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_roc_points</span><span class="p">,</span>
                        <span class="n">decision_boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">metrics</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">metrics</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">==</span><span class="s">&quot;multinomial&quot;</span><span class="p">:</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">MultinomialClassificationDataset</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span>
                        <span class="n">classification_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">,</span>
                        <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">==</span><span class="s">&quot;regression&quot;</span><span class="p">:</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">RegressionDataset</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span>
                <span class="n">regression_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="c"># add the training time if training was done</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Training_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_time</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">classifier_information</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span>\
                <span class="n">predictor</span><span class="o">.</span><span class="n">classifier_information</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">classifier_information</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>

        <span class="c"># add the training metrics</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span><span class="p">:</span>
            <span class="n">skip_keys</span> <span class="o">=</span> <span class="n">classifier_information</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">train_metrics</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">skip_keys</span><span class="p">:</span>
                    <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;train_&quot;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classification_dataset</span><span class="o">.</span><span class="n">add_split</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span>
                                                 <span class="n">train</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                 <span class="n">split</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_split</span><span class="p">,</span>
                                                 <span class="n">run</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_number</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_trace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">long_trace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calculate_classification_trace</span><span class="p">(</span>
                        <span class="n">classification_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">,</span>
                        <span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_soft_metrics</span><span class="p">,</span>
                        <span class="n">ir_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ir_class</span><span class="p">,</span> 
                        <span class="n">sec_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sec_class</span><span class="p">,</span>
                        <span class="n">loss_restriction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_restriction</span><span class="p">,</span>
                        <span class="n">calc_loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_loss</span><span class="p">,</span>
                        <span class="n">decision_boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="p">,</span>
                        <span class="n">save_trace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_trace</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Metrics added to dataset&quot;</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PerformanceSinkNode.set_helper_parameters"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode.set_helper_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">set_helper_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classification_vector</span><span class="p">,</span><span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Some node parameters must be fetched from the classification vectors &quot;&quot;&quot;</span>
            <span class="c"># get an example for a classification vector for further analysis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">example</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">example</span> <span class="o">=</span> <span class="n">classification_vector</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&quot;binary&quot;</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="o">=</span> \
                    <span class="n">classification_vector</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span><span class="n">classifier_information</span><span class="p">[</span><span class="s">&quot;decision_boundary&quot;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span><span class="n">node_name</span> <span class="ow">in</span> \
                            <span class="p">[</span><span class="s">&quot;PlattsSigmoidFitNode&quot;</span><span class="p">,</span>
                             <span class="s">&quot;LinearFitNode&quot;</span><span class="p">,</span>
                             <span class="s">&quot;SigmoidTransformationNode&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">prediction</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir_class</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">prediction</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span> <span class="ow">and</span> <span class="ow">not</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir_class</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">invert_classification</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&quot;binary&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">invert_classification</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&quot;Your ir_class did not get the higher value &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;from the classifier.</span><span class="se">\n</span><span class="s"> &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;Label, </span><span class="si">%s</span><span class="s">, got value, </span><span class="si">%f</span><span class="s">.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">prediction</span><span class="p">)</span> <span class="o">+</span>
                    <span class="s">&quot;You should adjust that  and &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;maybe switch the given class_labels or add &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;preserve_score: False to the &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;Threshold_Optimization node! &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;Furthermore you should check the parameter&quot;</span> <span class="o">+</span>
                    <span class="s">&quot;: decision_boundary!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&quot;binary&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sec_class</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">p_label</span> <span class="o">=</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sec_class</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">p_label</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ir_class</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sec_class</span> <span class="o">=</span> <span class="n">p_label</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="PerformanceSinkNode.calculate_classification_trace"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode.calculate_classification_trace">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_classification_trace</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">classification_results</span><span class="p">,</span>
                                       <span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                       <span class="n">ir_class</span><span class="o">=</span><span class="s">&quot;Target&quot;</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                       <span class="n">loss_restriction</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                                       <span class="n">calc_loss</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                       <span class="n">decision_boundary</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                                       <span class="n">save_trace</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the classification trace, i.e. TN,TP,FN,FP for every sample</span>
<span class="sd">        </span>
<span class="sd">        The trace entries are encoded for size reasons as short (trace) or </span>
<span class="sd">        in a comprehensive version as dicts (long_trace)</span>
<span class="sd">        </span>
<span class="sd">        The encoding in trace is:</span>
<span class="sd">        </span>
<span class="sd">            :TP: 0</span>
<span class="sd">            :FN: 1</span>
<span class="sd">            :FP: 2</span>
<span class="sd">            :TN: 3</span>
<span class="sd">        </span>
<span class="sd">        :Author: Hendrik Woehrle (hendrik.woehrle@dfki.de), Mario Krell (mario.krell@dfki.de)</span>
<span class="sd">        :Returns: trace, long_trace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">long_trace</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">prediction_vector</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="n">classification_results</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sec_class</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">label</span> <span class="o">==</span> <span class="n">ir_class</span><span class="p">:</span>
                <span class="n">sec_class</span> <span class="o">=</span> <span class="n">label</span>
            <span class="n">confusion_matrix</span> <span class="o">=</span> <span class="n">metricdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">update_confusion_matrix</span><span class="p">(</span><span class="n">prediction_vector</span><span class="p">,</span>
                                        <span class="n">label</span><span class="p">,</span><span class="n">calc_soft_metrics</span><span class="o">=</span><span class="n">calc_soft_metrics</span><span class="p">,</span>
                                        <span class="n">ir_class</span><span class="o">=</span><span class="n">ir_class</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="n">sec_class</span><span class="p">,</span>
                                        <span class="n">confusion_matrix</span><span class="o">=</span><span class="n">confusion_matrix</span><span class="p">,</span>
                                        <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">)</span>

            <span class="c"># </span>
            <span class="k">if</span> <span class="n">calc_loss</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">save_trace</span> <span class="o">==</span> <span class="s">&quot;short&quot;</span><span class="p">:</span>
                <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">update_loss_values</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">=</span><span class="n">prediction_vector</span><span class="p">,</span>
                                        <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                                        <span class="n">ir_class</span><span class="o">=</span><span class="n">ir_class</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="n">sec_class</span><span class="p">,</span>
                                        <span class="n">loss_dict</span><span class="o">=</span><span class="n">confusion_matrix</span><span class="p">,</span>
                                        <span class="n">loss_restriction</span><span class="o">=</span><span class="n">loss_restriction</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">save_trace</span> <span class="o">==</span> <span class="s">&quot;short&quot;</span><span class="p">:</span>
                <span class="n">long_trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;True_positives&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;False_negatives&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;False_positives&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;True_negatives&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;At least one element in the confusion matrix should be 1&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trace</span><span class="p">,</span> <span class="n">long_trace</span>
</div>
<div class="viewcode-block" id="PerformanceSinkNode.get_result_dataset"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode.get_result_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">get_result_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the result dataset &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_up_splits</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_dataset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">classification_dataset</span><span class="o">.</span><span class="n">merge_splits</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_dataset</span>
</div>
<div class="viewcode-block" id="PerformanceSinkNode.store_state"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode.store_state">[docs]</a>    <span class="k">def</span> <span class="nf">store_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result_dir</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Stores additional information (classification_outcome, roc_points) in the *result_dir* &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">:</span>
            <span class="n">node_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="n">create_directory</span><span class="p">(</span><span class="n">node_dir</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_individual_classifications</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;classification_outcome_sp</span><span class="si">%s</span><span class="s">.pickle&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span>
                <span class="n">result_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node_dir</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="s">&quot;wb&quot;</span><span class="p">)</span>
                <span class="c"># predictor is a reference to the actual classification node</span>
                <span class="c"># object. This can not be pickled! Therefore, replace the</span>
                <span class="c"># predictor attribute by the classification node&#39;s node_specs</span>
                <span class="k">for</span> <span class="n">single_classification</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">:</span>
                    <span class="n">single_classification</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">predictor</span> <span class="o">=</span> \
                            <span class="n">single_classification</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span><span class="n">node_specs</span>
                <span class="n">result_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">result_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_roc_points</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;roc_points_sp</span><span class="si">%s</span><span class="s">.pickle&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span>
                <span class="n">result_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node_dir</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="s">&quot;wb&quot;</span><span class="p">)</span>
                <span class="n">result_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">result_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_trace</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;trace_sp</span><span class="si">%s</span><span class="s">.pickle&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span>
                <span class="n">result_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node_dir</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="s">&quot;wb&quot;</span><span class="p">)</span>
                <span class="n">result_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">result_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_trace</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                    <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;long_trace_sp</span><span class="si">%s</span><span class="s">.pickle&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span>
                    <span class="n">result_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node_dir</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="s">&quot;wb&quot;</span><span class="p">)</span>
                    <span class="n">result_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">long_trace</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">result_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div></div>
<div class="viewcode-block" id="LeaveOneOutSinkNode"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.LeaveOneOutSinkNode">[docs]</a><span class="k">class</span> <span class="nc">LeaveOneOutSinkNode</span><span class="p">(</span><span class="n">PerformanceSinkNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Request the leave one out metrics from the input node </span>
<span class="sd">    </span>
<span class="sd">    **Parameters**</span>
<span class="sd">    </span>
<span class="sd">    see: :class:`PerformanceSinkNode`</span>
<span class="sd">    </span>
<span class="sd">    **Exemplary Call**</span>

<span class="sd">    .. code-block:: yaml</span>

<span class="sd">        -  </span>
<span class="sd">            node : LOO_Sink</span>
<span class="sd">            parameters :</span>
<span class="sd">                ir_class : &quot;Target&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LeaveOneOutSinkNode.process_current_split"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.LeaveOneOutSinkNode.process_current_split">[docs]</a>    <span class="k">def</span> <span class="nf">process_current_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get training results and input node metrics &quot;&quot;&quot;</span>
        <span class="c">### TRAINING ### # code copy till main part</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="n">start_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> \
                                   <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">request_data_for_training</span><span class="p">(</span><span class="bp">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_helper_parameters</span><span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="n">stop_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">training_time</span> <span class="o">=</span> <span class="n">stop_time_stamp</span> <span class="o">-</span> <span class="n">start_time_stamp</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span><span class="p">:</span>
            <span class="n">train_result</span> <span class="o">=</span> <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span>
                <span class="n">classification_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="p">,</span>
                <span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_soft_metrics</span><span class="p">,</span>
                <span class="n">invert_classification</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">invert_classification</span><span class="p">,</span>
                <span class="n">ir_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ir_class</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sec_class</span><span class="p">,</span>
                <span class="n">loss_restriction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_restriction</span><span class="p">,</span>
                <span class="n">time_periods</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">calc_AUC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_AUC</span><span class="p">,</span> <span class="n">calc_loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_loss</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">save_roc_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_roc_points</span><span class="p">,</span>
                <span class="n">decision_boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">train_metrics</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">train_R</span> <span class="o">=</span> <span class="n">train_result</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">train_metrics</span> <span class="o">=</span> <span class="n">train_result</span>
        <span class="c">######################### Main Part #########################</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span><span class="n">loo_metrics</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Input node does not provide LOO metrics.&quot;</span><span class="p">)</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="n">metricdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="c">#############################################################</span>
        <span class="c"># add the training time #Code copy from here</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Training_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_time</span>
        <span class="c"># add the training metrics</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">classifier_information</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span>\
                        <span class="n">classifier_information</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">classifier_information</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
            <span class="n">skip_keys</span><span class="o">=</span><span class="n">classifier_information</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">train_metrics</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">skip_keys</span><span class="p">:</span>
                    <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;train_&quot;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classification_dataset</span><span class="o">.</span><span class="n">add_split</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span>
                                              <span class="n">train</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                              <span class="n">split</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_split</span><span class="p">,</span>
                                              <span class="n">run</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_number</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="SlidingWindowSinkNode"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.SlidingWindowSinkNode">[docs]</a><span class="k">class</span> <span class="nc">SlidingWindowSinkNode</span><span class="p">(</span><span class="n">PerformanceSinkNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate and store performance measures from classifications of sliding windows</span>
<span class="sd">    </span>
<span class="sd">    This node inherits most of its functionality from *PerformanceSinkNode*.</span>
<span class="sd">    Thus, for parameter description of super class parameters see documentation</span>
<span class="sd">    of *PerformanceSinkNode*.</span>
<span class="sd">    </span>
<span class="sd">    Additionally the following functionality is provided:</span>
<span class="sd">    </span>
<span class="sd">    1) The definition of uncertain areas, which are excluded in the metrics </span>
<span class="sd">    calculation process, are possible. This is useful for sliding window </span>
<span class="sd">    classification, i.e. if the true label is not known in each sliding step. </span>
<span class="sd">    2) It is possible to label the test data only now. For that an epoch signal </span>
<span class="sd">    (e.g. a movement marker window) must be specified. </span>
<span class="sd">    3) Instead of excluding sliding windows from classifier evaluation, the</span>
<span class="sd">    &#39;true&#39; label function shape (a step function, which is zero for the </span>
<span class="sd">    negative class and one for the positive class) can be somehow fit in the </span>
<span class="sd">    uncertain range. At the moment there is only one way for doing this:</span>
<span class="sd">    </span>
<span class="sd">        * from_right_count_negatives: Find the point where prediction of the </span>
<span class="sd">                                   negative class starts by searching backwards </span>
<span class="sd">                                   in time. There can be specified how many </span>
<span class="sd">                                   &#39;outliers&#39; are ignored, i.e. how stable the </span>
<span class="sd">                                   prediction has to be.</span>
<span class="sd">    </span>
<span class="sd">    .. note:: At the moment plots can only be made when each epoch has the same</span>
<span class="sd">              length (i.e. not if option 2) or 3) is active).</span>
<span class="sd">    </span>
<span class="sd">    **Parameters**</span>
<span class="sd">    </span>
<span class="sd">        :uncertain_area:</span>
<span class="sd">            A list of tuples of the lower and the upper time value (in ms) for which</span>
<span class="sd">            no metrics calculation is done. The values should be given with respect</span>
<span class="sd">            to the last window of an epoch, i.e. sliding window series (which has </span>
<span class="sd">            time value zero). </span>
<span class="sd">            If additionally *determine_labels* is specified then the first tuple of </span>
<span class="sd">            *uncertain_area* describes the bounds in which the label-change-point is</span>
<span class="sd">            determined. The lower bound should be the earliest time point when the </span>
<span class="sd">            detection makes sense; the upper bound should be the earliest time point</span>
<span class="sd">            when there MUST BE a member of the positive class.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: None*)</span>
<span class="sd">            </span>
<span class="sd">        :sliding_step:</span>
<span class="sd">            The time (in ms) between two consecutive windows.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: 50*)</span>
<span class="sd">        </span>
<span class="sd">        :determine_labels:</span>
<span class="sd">            If specified the label-change-point (index where the class label changes</span>
<span class="sd">            from negative to positive class) is determined for every epoch. This is</span>
<span class="sd">            done via counting the occurrence of negative classified sliding windows</span>
<span class="sd">            from the index point where the positive class is sure </span>
<span class="sd">            (uncertain_area[1]) to the index point where the negative class is sure</span>
<span class="sd">            (uncertain_area[0]) If *determine_labels* instances were found in </span>
<span class="sd">            consecutively windows the label-change-point is has been reached. </span>
<span class="sd">            If *determine_labels* &gt; 1, the methods accounts for outliers.</span>
<span class="sd">            </span>
<span class="sd">            .. note:: Using this option makes it hard to figure out to which true</span>
<span class="sd">                     class errors pertain (since it is somehow arbitrary). You </span>
<span class="sd">                     should be careful which metric you analyze for performance</span>
<span class="sd">                     evaluation (different class instance costs can&#39;t be modeled).</span>
<span class="sd">                     </span>
<span class="sd">        :epoch_signal:</span>
<span class="sd">            The class name (label) of the event that marks the end of an epoch,</span>
<span class="sd">            e.g. the movement. This can be used when null_marker windows (of an </span>
<span class="sd">            unknown class) and a signal window which marks the event were cut out.</span>
<span class="sd">            With respect to this event the former windows will be relabeled </span>
<span class="sd">            according to *classes_names*.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: None*)</span>
<span class="sd">        </span>
<span class="sd">        :epoch_eval:</span>
<span class="sd">            If True, evaluation is done per epoch, i.e. per movement. Performance</span>
<span class="sd">            metrics are averaged across epochs for every split. This option might</span>
<span class="sd">            be necessary if the epochs have variable length, i.e. the class</span>
<span class="sd">            distribution alters in every epoch.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: False*)</span>
<span class="sd">            </span>
<span class="sd">        :save_score_plot:</span>
<span class="sd">            If True a plot is stored which shows the average prediction value</span>
<span class="sd">            against the time point of classification.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: False*)</span>
<span class="sd">        </span>
<span class="sd">        :save_trial_plot:</span>
<span class="sd">            If True a plot is stored which shows developing of the prediction</span>
<span class="sd">            scores for each single trial.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: False*)</span>
<span class="sd">            </span>
<span class="sd">        :sort: </span>
<span class="sd">            If True the data has to be sorted according to the time (encoded in the</span>
<span class="sd">            tag attribute. Be aware that this only makes sense for data sets with</span>
<span class="sd">            unique time tags.</span>
<span class="sd">            </span>
<span class="sd">            (*optional, default: False*)</span>
<span class="sd">        </span>
<span class="sd">    **Exemplary Call**</span>

<span class="sd">    .. code-block:: yaml</span>

<span class="sd">        -  </span>
<span class="sd">            node : Sliding_Window_Performance_Sink</span>
<span class="sd">            parameters :</span>
<span class="sd">                ir_class : &quot;LRP&quot;</span>
<span class="sd">                classes_names : [&#39;NoLRP&#39;,&#39;LRP&#39;]</span>
<span class="sd">                uncertain_area : [&#39;(-600,-350)&#39;]</span>
<span class="sd">                calc_soft_metrics : True</span>
<span class="sd">                save_score_plot : True</span>

<span class="sd">    :input:  PredictionVector</span>
<span class="sd">    :output: ClassificationCollection</span>
<span class="sd">    :Author: Anett Seeland (anett.seeland@dfki.de)</span>
<span class="sd">    :Created: 2011/01/23</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SlidingWindowSinkNode.__init__"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.SlidingWindowSinkNode.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">uncertain_area</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sliding_step</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">save_score_plot</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                 <span class="n">save_trial_plot</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">determine_labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">epoch_eval</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
                 <span class="n">epoch_signal</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SlidingWindowSinkNode</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">uncertain_area</span><span class="o">=</span><span class="n">uncertain_area</span><span class="p">,</span>
                                      <span class="n">sliding_step</span><span class="o">=</span><span class="n">sliding_step</span><span class="p">,</span>
                                      <span class="n">determine_labels</span><span class="o">=</span><span class="n">determine_labels</span><span class="p">,</span>
                                      <span class="n">epoch_signal</span><span class="o">=</span><span class="n">epoch_signal</span><span class="p">,</span>
                                      <span class="n">epoch_eval</span><span class="o">=</span><span class="n">epoch_eval</span><span class="p">,</span>
                                      <span class="n">save_score_plot</span><span class="o">=</span><span class="n">save_score_plot</span><span class="p">,</span>
                                      <span class="n">save_trial_plot</span><span class="o">=</span><span class="n">save_trial_plot</span><span class="p">,</span>
                                      <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">save_score_plot</span> <span class="ow">or</span> <span class="n">save_trial_plot</span>
        </div>
<div class="viewcode-block" id="SlidingWindowSinkNode.process_current_split"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.SlidingWindowSinkNode.process_current_split">[docs]</a>    <span class="k">def</span> <span class="nf">process_current_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the results of this sink node for the current split of the </span>
<span class="sd">        data into train and test data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">### TRAINING ###</span>
        <span class="c"># Code from classificationSinkNode #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Processing training data&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="n">start_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">request_data_for_training</span><span class="p">(</span><span class="bp">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_helper_parameters</span><span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">classification_vector</span><span class="p">,</span>
                                                          <span class="n">label</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="n">stop_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">training_time</span> <span class="o">=</span> <span class="n">stop_time_stamp</span> <span class="o">-</span> <span class="n">start_time_stamp</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span><span class="p">:</span>
            <span class="n">train_result</span> <span class="o">=</span> <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span>
                <span class="n">classification_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">train_classification_outcome</span><span class="p">,</span>
                <span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_soft_metrics</span><span class="p">,</span>
                <span class="n">invert_classification</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">invert_classification</span><span class="p">,</span>
                <span class="n">ir_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ir_class</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sec_class</span><span class="p">,</span>
                <span class="n">loss_restriction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_restriction</span><span class="p">,</span>
                <span class="n">time_periods</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">calc_AUC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_AUC</span><span class="p">,</span><span class="n">calc_loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_loss</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span><span class="n">save_roc_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_roc_points</span><span class="p">,</span>
                <span class="n">decision_boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">train_metrics</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">train_R</span> <span class="o">=</span> <span class="n">train_result</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">train_metrics</span> <span class="o">=</span> <span class="n">train_result</span>

        <span class="c"># TESTING</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Processing testing data&quot;</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
        <span class="n">confusion_matrix</span><span class="o">=</span><span class="n">metricdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="c"># for saving the actual numerical classification results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="c"># class\guess ir sec</span>
        <span class="c"># ir_class:   TP FN</span>
        <span class="c"># sec_class:  FP TN</span>
        
        <span class="c"># initialization to measure execution speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_periods</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="n">start_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
            
        <span class="k">for</span> <span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">request_data_for_testing</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
                <span class="n">stop_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_periods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stop_time_stamp</span> <span class="o">-</span> <span class="n">start_time_stamp</span><span class="p">)</span>
            
            <span class="c"># deprecated if the dataset has been sort</span>
            <span class="c"># parse &#39;tag&#39;: &#39;Epoch Start: 395772ms; End: 396772ms; Class: Target&#39;</span>
            <span class="n">classification_vector</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s">&#39;start_time&#39;</span><span class="p">]</span><span class="o">=</span> \
                <span class="nb">float</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;ms&#39;</span><span class="p">))</span>
            <span class="n">classification_vector</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s">&#39;end_time&#39;</span><span class="p">]</span><span class="o">=</span> \
                <span class="nb">float</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;ms&#39;</span><span class="p">))</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">classification_vector</span><span class="p">,</span><span class="n">label</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
                <span class="n">start_time_stamp</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">example</span> <span class="o">=</span> <span class="n">classification_vector</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">:</span>
            <span class="c"># sort classification vectors in time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tupel</span><span class="p">:</span><span class="n">tupel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s">&#39;start_time&#39;</span><span class="p">])</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_signal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
            <span class="c"># split according to signal</span>
            <span class="k">for</span> <span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_signal</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># split windows according to the time</span>
            <span class="n">last_window_end_time</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>          
            <span class="k">for</span> <span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">:</span>
                <span class="c">#print classification_vector.specs[&#39;start_time&#39;], label</span>
                <span class="k">if</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s">&#39;start_time&#39;</span><span class="p">]</span> <span class="o">&gt;</span> \
                        <span class="n">last_window_end_time</span> <span class="ow">or</span> \
                        <span class="n">classification_vector</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s">&#39;end_time&#39;</span><span class="p">]</span> <span class="o">&lt;</span> \
                        <span class="n">last_window_end_time</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">)]</span>
                <span class="k">elif</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s">&#39;end_time&#39;</span><span class="p">]</span> <span class="o">==</span> \
                                       <span class="n">last_window_end_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sliding_step</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">classification_vector</span><span class="p">,</span>
                                                   <span class="n">label</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s">&#39;wdef_name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;bis-4000&quot;</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">marker</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># TODO: overlapping epochs - what shall we do???</span>
                    <span class="c"># may be store it with marker = -1 and handle it afterwards</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Error: Overlapping epochs in Sink detected!&quot;</span><span class="p">,</span>
                    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
                    <span class="c">#raise Exception(&quot;Overlapping epochs in Sink detected!&quot;)</span>
                <span class="n">last_window_end_time</span> <span class="o">=</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s">&#39;end_time&#39;</span><span class="p">]</span>
        
        <span class="c"># delete uncertain classification outcomes or relabel data in </span>
        <span class="c"># self.classification_outcome and calculate the confusion matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_change_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">performance</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_labels</span><span class="p">:</span>
                <span class="c"># calculate uncertain indices</span>
                <span class="n">nr_sliding_windows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertain_area</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
                    <span class="n">bound_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_sliding_windows</span> <span class="o">-</span> \
                           <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uncertain_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sliding_step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                           <span class="n">nr_sliding_windows</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uncertain_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span> \
                           <span class="bp">self</span><span class="o">.</span><span class="n">sliding_step</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uncertain_area</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">uncertain_indices</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertain_area</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="n">uncertain_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nr_sliding_windows</span> <span class="o">-</span> \
                                                <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sliding_step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                <span class="n">nr_sliding_windows</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span> \
                                                <span class="bp">self</span><span class="o">.</span><span class="n">sliding_step</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">uncertain_indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c"># if not specified, assume unbound</span>
                    <span class="n">bound_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_sliding_windows</span><span class="p">)</span>
                    <span class="n">uncertain_indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">label_change_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_right_count_negatives</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_labels</span><span class="p">,</span> <span class="n">bound_indices</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_change_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label_change_point</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> \
                                              <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uncertain_indices</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">label_change_point</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                 <span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                 <span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_names</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>  
                <span class="c"># calculate uncertain indices</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertain_area</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
                    <span class="n">nr_sliding_windows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">uncertain_indices</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertain_area</span><span class="p">:</span>
                        <span class="n">uncertain_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nr_sliding_windows</span> <span class="o">-</span> \
                              <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sliding_step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="n">nr_sliding_windows</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sliding_step</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">uncertain_indices</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> \
                                              <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">uncertain_indices</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_signal</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">uncertain_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_names</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">classification_vector</span><span class="p">,</span>
                                                                         <span class="n">label</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_eval</span><span class="p">:</span>
                <span class="c"># not all columns make sense in this case, </span>
                <span class="c"># so AUC and ROC points are switched off</span>
                <span class="n">result</span><span class="o">=</span> <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span>
                        <span class="n">classification_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">,</span>
                        <span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_soft_metrics</span><span class="p">,</span>
                        <span class="n">invert_classification</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">invert_classification</span><span class="p">,</span>
                        <span class="n">ir_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ir_class</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sec_class</span><span class="p">,</span>
                        <span class="n">loss_restriction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_restriction</span><span class="p">,</span>
                        <span class="n">time_periods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_periods</span><span class="p">,</span>
                        <span class="n">calc_AUC</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">calc_loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_loss</span><span class="p">,</span>
                        <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span><span class="n">save_roc_points</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                        <span class="n">decision_boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">performance</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">performance</span> <span class="o">=</span> <span class="n">result</span>
                <span class="k">else</span><span class="p">:</span> <span class="c"># combine with old performance</span>
                    <span class="n">new_performance</span> <span class="o">=</span> <span class="n">result</span>
                    <span class="n">performance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_perf_dict</span><span class="p">(</span><span class="n">performance</span><span class="p">,</span> 
                                                         <span class="n">new_performance</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_eval</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span>
                        <span class="n">classification_results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">classification_outcome</span><span class="p">,</span>
                        <span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_soft_metrics</span><span class="p">,</span>
                        <span class="n">invert_classification</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">invert_classification</span><span class="p">,</span>
                        <span class="n">ir_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ir_class</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sec_class</span><span class="p">,</span>
                        <span class="n">loss_restriction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_restriction</span><span class="p">,</span>
                        <span class="n">time_periods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_periods</span><span class="p">,</span>
                        <span class="n">calc_AUC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_AUC</span><span class="p">,</span><span class="n">calc_loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_loss</span><span class="p">,</span>
                        <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span><span class="n">save_roc_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_roc_points</span><span class="p">,</span>
                        <span class="n">decision_boundary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decision_boundary</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">performance</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">performance</span> <span class="o">=</span> <span class="n">result</span>
        <span class="c"># add the training time</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_times</span><span class="p">:</span>
            <span class="n">performance</span><span class="p">[</span><span class="s">&quot;Training_time&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_time</span>
        <span class="c"># add the training metrics</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_train</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">train_metrics</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">performance</span><span class="p">[</span><span class="s">&quot;train_&quot;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_labels</span><span class="p">:</span>
            <span class="n">performance</span><span class="p">[</span><span class="s">&quot;~~Avg_Label_Change_Index~~&quot;</span><span class="p">]</span> <span class="o">=</span> \
                                            <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_change_points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classification_dataset</span><span class="o">.</span><span class="n">add_split</span><span class="p">(</span><span class="n">performance</span><span class="p">,</span>
                                                 <span class="n">train</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
                                                 <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span><span class="p">,</span>
                                                 <span class="n">run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_number</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Metrics added to dataset&quot;</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SlidingWindowSinkNode.from_right_count_negatives"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.SlidingWindowSinkNode.from_right_count_negatives">[docs]</a>    <span class="k">def</span> <span class="nf">from_right_count_negatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">target_number</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Go through the bounded y (reverse) and find the index i, where </span>
<span class="sd">        target_number values have been consecutively the negative class.</span>
<span class="sd">        Return i+target_number as critical index point (labels change)&quot;&quot;&quot;</span>
        <span class="n">countNegatives</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">countTotal</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">countTotal</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">classes_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">countNegatives</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">countNegatives</span><span class="o">==</span><span class="n">target_number</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">countTotal</span><span class="o">==</span><span class="n">target_number</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">index</span><span class="o">+</span><span class="n">target_number</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">countNegatives</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">return</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">countNegatives</span>
</div>
<div class="viewcode-block" id="SlidingWindowSinkNode.combine_perf_dict"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.SlidingWindowSinkNode.combine_perf_dict">[docs]</a>    <span class="k">def</span> <span class="nf">combine_perf_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_dict</span><span class="p">,</span> <span class="n">new_dict</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Combine the values of the dicts by a weighting (iterative) average</span>
<span class="sd">           </span>
<span class="sd">           .. math:: \\frac{weight-1}{weight} \\cdot \\text{old\_dict} + \\frac{1}{weight} \\cdot \\text{new\_dict}</span>
<span class="sd">           </span>
<span class="sd">           &quot;&quot;&quot;</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">old_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">weight</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">weight</span> <span class="o">*</span> <span class="n">old_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> \
                               <span class="mf">1.0</span><span class="o">/</span><span class="n">weight</span> <span class="o">*</span> <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span> <span class="c"># for Strings (like parameters)</span>
                <span class="c"># they should not be different among epochs</span>
                <span class="k">if</span> <span class="n">old_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">return_dict</span>    
</div>
<div class="viewcode-block" id="SlidingWindowSinkNode.store_state"><a class="viewcode-back" href="../../../../../api/generated/pySPACE.missions.nodes.sink.classification_performance_sink.html#pySPACE.missions.nodes.sink.classification_performance_sink.SlidingWindowSinkNode.store_state">[docs]</a>    <span class="k">def</span> <span class="nf">store_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result_dir</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Stores additional information in the given directory *result_dir* &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">:</span>
            <span class="n">node_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="n">create_directory</span><span class="p">(</span><span class="n">node_dir</span><span class="p">)</span>
            
            <span class="nb">super</span><span class="p">(</span><span class="n">SlidingWindowSinkNode</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">store_state</span><span class="p">(</span><span class="n">result_dir</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_score_plot</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_trial_plot</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="n">classification_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> \
                       <span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="k">for</span> \
                       <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">means</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">stds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sliding_step</span><span class="p">,</span>
                                                                         <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_score_plot</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">&#39;major&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;grey&#39;</span><span class="p">,</span>
                               <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">&#39;major&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;grey&#39;</span><span class="p">,</span>
                               <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="n">width</span> <span class="o">=</span> <span class="mi">30</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">stds</span><span class="p">,</span> <span class="n">ecolor</span><span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">)</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">width</span><span class="p">,</span><span class="n">ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">width</span><span class="p">)</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">means</span><span class="p">)</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">stds</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">means</span><span class="p">)</span><span class="o">+</span><span class="nb">max</span><span class="p">(</span><span class="n">stds</span><span class="p">))</span>
                
                <span class="n">t</span> <span class="o">=</span> <span class="n">result_dir</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;{}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;}{&quot;</span><span class="p">)</span>
                <span class="n">title</span> <span class="o">=</span> <span class="s">&quot;SVM score average: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Average SVM prediction value&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Time point of classification [ms]&#39;</span><span class="p">)</span>
                
                <span class="n">params</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
                    <span class="n">params</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;average_score_plot_sp</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_split</span><span class="p">,</span> 
                                                                         <span class="n">params</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node_dir</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">facecolor</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="n">papertype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">orientation</span><span class="o">=</span><span class="s">&#39;portrait&#39;</span><span class="p">,</span> <span class="n">transparent</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                    
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_trial_plot</span><span class="p">:</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                <span class="n">num_trials</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_cols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_trials</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="p">))</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">((</span><span class="mi">10</span><span class="o">*</span><span class="n">num_cols</span><span class="p">,</span> <span class="mi">6</span><span class="o">*</span><span class="n">num_rows</span><span class="p">))</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">trial</span><span class="p">)])</span>
                    <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">ymax</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">trial</span><span class="p">)])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">&#39;major&#39;</span><span class="p">,</span> 
                                  <span class="n">color</span><span class="o">=</span><span class="s">&#39;grey&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">&#39;major&#39;</span><span class="p">,</span> 
                                  <span class="n">color</span><span class="o">=</span><span class="s">&#39;grey&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="s">&#39;o&#39;</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span><span class="p">)</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_time</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="s">&quot;Classification from &quot;</span><span class="o">+</span><span class="n">start</span><span class="o">+</span><span class="s">&quot; to: &quot;</span><span class="o">+</span><span class="n">end</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;SVM prediction value&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Time point of classification [ms]&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_change_points</span> <span class="o">!=</span> <span class="p">[]:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_change_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> \
                                                            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sliding_step</span>
                        <span class="c"># plot a line when positive class starts</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">],[</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span><span class="p">])</span>
                        <span class="n">x_search_low</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertain_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">x_search_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertain_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c"># plot dashed lines to indicate bounds (where the label</span>
                        <span class="c"># change point could be)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x_search_low</span><span class="p">,</span><span class="n">x_search_low</span><span class="p">],[</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span><span class="p">],</span><span class="s">&#39;r--&#39;</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x_search_up</span><span class="p">,</span> <span class="n">x_search_up</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span><span class="p">],</span><span class="s">&#39;r--&#39;</span><span class="p">)</span>
                <span class="c">#fig.text(0.4, 0.98, &quot;Sliding window classifications; BA: &quot; + \</span>
                <span class="c">#         str(self.performance[&quot;Balanced_accuracy&quot;]), size=14)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;single-trails_score_plot_sp</span><span class="si">%s</span><span class="s">.pdf&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node_dir</span><span class="p">,</span><span class="n">name</span><span class="p">),</span><span class="n">dpi</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">facecolor</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">,</span>
                            <span class="n">edgecolor</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">,</span><span class="n">orientation</span><span class="o">=</span><span class="s">&#39;portrait&#39;</span><span class="p">,</span><span class="n">papertype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">transparent</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>


<span class="c"># Specify special node names</span></div></div>
<span class="n">_NODE_MAPPING</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Classification_Performance_Sink&quot;</span><span class="p">:</span> <span class="n">PerformanceSinkNode</span><span class="p">,</span>
                 <span class="s">&quot;ClassificationSinkNode&quot;</span><span class="p">:</span> <span class="n">PerformanceSinkNode</span><span class="p">,</span>
                <span class="s">&quot;Sliding_Window_Performance_Sink&quot;</span><span class="p">:</span> <span class="n">SlidingWindowSinkNode</span><span class="p">,</span>
                <span class="s">&quot;LOO_Sink&quot;</span><span class="p">:</span><span class="n">LeaveOneOutSinkNode</span><span class="p">,</span>
                <span class="s">&quot;LOOSink&quot;</span><span class="p">:</span><span class="n">LeaveOneOutSinkNode</span><span class="p">,</span>
                <span class="p">}</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../../index.html">pySPACE 0.5 alpha documentation</a> &raquo;</li>
          <li><a href="../../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, pySPACE Developer Team.
      Last updated on Aug 07, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>