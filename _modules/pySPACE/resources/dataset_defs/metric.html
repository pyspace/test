

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pySPACE.resources.dataset_defs.metric &mdash; pySPACE 0.5 alpha documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/pySPACE.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.5 alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/pyspace-logo.ico"/>
    <link rel="top" title="pySPACE 0.5 alpha documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">pySPACE 0.5 alpha documentation</a> &raquo;</li>
          <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/pyspace-logo_small.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pySPACE.resources.dataset_defs.metric</h1><div class="highlight"><pre>
<span class="c"># This Python file uses the following encoding: utf-8</span>
<span class="c"># The upper line is needed for one comment in this module.</span>
<span class="c"># coding=utf-8</span>
<span class="sd">&quot;&quot;&quot; Methods to calculate and store classification results (metrics)</span>

<span class="sd">Several performance measures are supported.</span>

<span class="sd">To combine and visualize them, use the</span>
<span class="sd">:class:`~pySPACE.resources.dataset_defs.performance_result.PerformanceResultSummary`.</span>

<span class="sd">For details concerning parameters in metric calculation, have a look at</span>
<span class="sd">:class:`~pySPACE.missions.nodes.sink.classification_performance_sink.PerformanceSinkNode`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">exp</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">from</span> <span class="nn">pySPACE.resources.dataset_defs.base</span> <span class="kn">import</span> <span class="n">BaseDataset</span>

<div class="viewcode-block" id="metricdict"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.metricdict">[docs]</a><span class="k">class</span> <span class="nc">metricdict</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Interface to dictionaries of metrics &quot;&quot;&quot;</span>
<div class="viewcode-block" id="metricdict.__missing__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.metricdict.__missing__">[docs]</a>    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return first occurring fitting entry and give warning, if functional metric is called without parameters &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">new_key</span><span class="o">+</span><span class="s">&quot;(&quot;</span><span class="p">):</span>
                    <span class="kn">import</span> <span class="nn">warnings</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Using key: &#39;</span><span class="si">%s</span><span class="s">&#39; instead of: &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">new_key</span><span class="p">))</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">metricdict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__missing__</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="BinaryClassificationDataset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset">[docs]</a><span class="k">class</span> <span class="nc">BinaryClassificationDataset</span><span class="p">(</span><span class="n">BaseDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Handle and store binary classification performance measures</span>

<span class="sd">    This class derived from BaseDataset overwrites the &#39;store&#39; and</span>
<span class="sd">    &#39;add_split&#39; method from the BaseDataset class so that it can</span>
<span class="sd">    handle and store classification performance measures to files.</span>

<span class="sd">    In the following there is a list of implemented metrics.</span>
<span class="sd">    After giving the normal name or abbreviation, the name in the final</span>
<span class="sd">    results file/dictionary is given.</span>
<span class="sd">    This is for example needed for parameter optimization algorithms.</span>

<span class="sd">    .. todo:: Move metrics to external rst file for better linking and</span>
<span class="sd">              summarize it with multinomial metrics.</span>

<span class="sd">    .. _metrics:</span>

<span class="sd">    **Metrics**</span>

<span class="sd">      :confusion matrix components:</span>
<span class="sd">        :TP - True_positives:</span>
<span class="sd">            correct classified examples or the *ir_class* (positive examples)</span>

<span class="sd">        :TN - True_negatives:</span>
<span class="sd">            correct classified examples or the *ir_class* (negative examples)</span>

<span class="sd">        :FN - False_negatives:</span>
<span class="sd">            wrong classified positive examples (classified as negative examples)</span>

<span class="sd">        :FP - False_positives:</span>
<span class="sd">            wrong classified negative examples (classified as positive examples)</span>

<span class="sd">      :confusion matrix metrics:</span>
<span class="sd">        :TPR - True_positive_rate:</span>
<span class="sd">            true positive rate, recall</span>

<span class="sd">            .. math:: \\frac{TP}{TP+FN}</span>

<span class="sd">        :PPV - IR_precision:</span>
<span class="sd">            positive predictive value, precision</span>

<span class="sd">            .. math:: \\frac{TP}{TP+FP}</span>

<span class="sd">        :TNR - True_negative_rate:</span>
<span class="sd">            true negative rate, specificity</span>

<span class="sd">            .. math:: \\frac{TN}{TN+FP}</span>

<span class="sd">        :NPV - Non_IR_precision:</span>
<span class="sd">            negative predictive value</span>

<span class="sd">            .. math:: \\frac{TN}{TN+FN}</span>

<span class="sd">        :FPR - False_positive_rate:</span>
<span class="sd">            false positive rate</span>

<span class="sd">            .. math:: 1-TNR = \\frac{FP}{TN+FP}</span>

<span class="sd">        :FNR - False_negative_rate:</span>
<span class="sd">            false negative rate</span>

<span class="sd">            .. math:: 1-TPR = \\frac{FN}{TP+FN}</span>

<span class="sd">        :accuracy - Percent_correct:</span>
<span class="sd">            rate of correct classified examples (sometimes percent correct)</span>

<span class="sd">            .. math:: \\frac{TP+TN}{TN+FP+FN+TP}</span>

<span class="sd">        :misclassification rate - Percent_incorrect:</span>
<span class="sd">            error rate, (sometimes percent incorrect)</span>

<span class="sd">            .. math:: \\frac{FP+FN}{TN+FP+FN+TP}</span>

<span class="sd">        :F-Measure - F_measure:</span>
<span class="sd">            harmonic mean of TNR and NPV</span>

<span class="sd">            .. math:: \\frac{2 \\cdot PPV \\cdot TPR}{PPV+TPR}=\\frac{2}{\\frac{1}{PPV}+\\frac{1}{TPR}}</span>

<span class="sd">        :F-neg-measure - Non_IR_F_measure:</span>
<span class="sd">            F-measure for negative class</span>

<span class="sd">            .. math:: \\frac{2 \\cdot NPV\\cdot TNR}{NPV+TNR}</span>

<span class="sd">        :Weighted F-measure - not implemented yet:</span>
<span class="sd">            .. math:: \\text{lambda } x: \\frac{(1+x^2)\\cdot PPV\\cdot TPR}{x^2 \\cdot PPV+TPR}</span>

<span class="sd">        :Weighted accuracy (t) - Weighted_accuracy(t):</span>
<span class="sd">            .. math:: t\\cdot TPR + (1-t)\\cdot TNR</span>

<span class="sd">        :ROC-measure:</span>
<span class="sd">            .. math:: \\sqrt{\\frac{TPR^2+TNR^2}{2}}</span>

<span class="sd">        :balanced accuracy - Balanced_accuracy:</span>
<span class="sd">            .. math:: \\frac{TNR + TPR}{2}</span>

<span class="sd">        :Gmean:</span>
<span class="sd">            .. math:: \\sqrt{(TPR \\cdot TNR)}</span>

<span class="sd">        :AUC:</span>
<span class="sd">            The area under the Receiver Operator Characteristic. Equal to the</span>
<span class="sd">            Wilcoxon test of ranks or to the probability, that a classifier will</span>
<span class="sd">            rank a randomly chosen positive instance higher than a randomly</span>
<span class="sd">            chosen negative one.</span>

<span class="sd">        :MCC-  Matthews_correlation_coefficient:</span>

<span class="sd">            .. math:: \\frac{TP*TN-FP*FN}{\\sqrt{((TP+FN)*(TP+FP)*(TN+FN)*(TN+FP))}}</span>


<span class="sd">    **K-metrics**</span>
<span class="sd">        These metrics expect classification values between zero and one.</span>
<span class="sd">        Instead of calculating the number of correct classifications,</span>
<span class="sd">        the corresponding sums of classification values are built.</span>
<span class="sd">        The misclassification values we get, by using one minus c-value.</span>
<span class="sd">        This also defines a confusion matrix, which is used to calculate the</span>
<span class="sd">        upper metrics.</span>

<span class="sd">        the notation is *k_* + normal name of metric.</span>

<span class="sd">    **Loss metrics**</span>
<span class="sd">        Some classifiers like LDA, SVM and RMM have loss terms in there model</span>
<span class="sd">        description. These misclassification values can be also calculated</span>
<span class="sd">        on test data, to evaluate the algorithm.</span>

<span class="sd">        The longest name used is *loss_balanced_rest_L1_SVM*</span>
<span class="sd">        and the shortest is *loss_L2*.</span>

<span class="sd">        In the LDA case, you skip the *SVM* component.</span>
<span class="sd">        If you want to weight the losses equally and not consider class imbalance,</span>
<span class="sd">        skip the *balanced* component and</span>
<span class="sd">        if you do not want to restrict the maximum loss, delete the *rest* component.</span>

<span class="sd">        The parameters *calc_loss* and *loss_restriction* can be specified.</span>

<span class="sd">    .. todo::   soft and pol metrics have to be checked</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        :dataset_md:</span>
<span class="sd">            The meta data of the current input</span>

<span class="sd">            (*optional, default: None*)</span>

<span class="sd">    :Author: Mario Krell (mario.krell@dfki.de)</span>
<span class="sd">    :Created: 2010/04/01</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BinaryClassificationDataset.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_md</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">dataset_pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c">#: The data structure containing the actual data.</span>
        <span class="c">#:</span>
        <span class="c">#: The data is stored as a dictionary that maps</span>
        <span class="c">#: (run, split, train/test) tuple to the actual</span>
        <span class="c">#: data obtained in this split in this run for</span>
        <span class="c">#: training/testing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_pattern</span> <span class="o">=</span> <span class="n">dataset_pattern</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;train_test&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                          <span class="s">&quot;splits&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                          <span class="s">&quot;runs&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> <span class="c">#: A dictionary containing some default meta data for the respective dataset</span>
</div>
<div class="viewcode-block" id="BinaryClassificationDataset.store"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.store">[docs]</a>    <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result_dir</span><span class="p">,</span> <span class="n">s_format</span> <span class="o">=</span> <span class="s">&quot;csv&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Handle meta data and meta information and save result as csv table</span>

<span class="sd">        This table is later on merged with the other results</span>
<span class="sd">        to one big result table.</span>

<span class="sd">        .. todo:: Try to use *PerformanceResultSummary* or *csv_analysis* methods and</span>
<span class="sd">                  furthermore sort the keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;results&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s_format</span> <span class="o">==</span> <span class="s">&quot;csv&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;The format </span><span class="si">%s</span><span class="s"> is not supported! Using default.&quot;</span><span class="o">%</span><span class="n">s_format</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">performance</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="c"># Construct result directory</span>
            <span class="n">result_path</span> <span class="o">=</span> <span class="n">result_dir</span>
            <span class="n">final_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">result_path</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">result_path</span><span class="p">)</span>
            <span class="n">key_str</span> <span class="o">=</span> <span class="s">&quot;_r</span><span class="si">%s</span><span class="s">_sp</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">_&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="c"># run number, split number, if performance on training or test data</span>
            <span class="n">key_str</span> <span class="o">+=</span> <span class="n">result_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c"># set name used for identifier</span>
            <span class="n">result_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">final_path</span><span class="p">,</span>
                                            <span class="n">name</span> <span class="o">+</span> <span class="n">key_str</span> <span class="o">+</span> <span class="s">&quot;.csv&quot;</span><span class="p">),</span>
                               <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="c"># Data saved in operation directory instead of current set directory</span>

            <span class="n">performance</span><span class="p">[</span><span class="s">&quot;Key_Dataset&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">result_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">results_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">result_file</span><span class="p">)</span>

            <span class="c"># if dataset_pattern given, add keys/vals</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_pattern</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">current_dataset</span> <span class="o">=</span> <span class="p">(</span><span class="n">performance</span><span class="p">[</span><span class="s">&quot;Key_Dataset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&quot;&#39;}{&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;}{&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">new_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_pattern</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)</span>
                    <span class="c"># make &#39;__MyNiceKey__&#39; from &#39;myNiceKey&#39;:</span>
                    <span class="n">new_keys</span><span class="o">=</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;__&#39;</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="s">&#39;__&#39;</span><span class="p">,</span> <span class="n">new_keys</span><span class="p">)</span>
                    <span class="n">new_vals</span> <span class="o">=</span> <span class="n">current_dataset</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">new_key_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_keys</span><span class="p">)):</span>
                        <span class="n">performance</span><span class="p">[</span><span class="n">new_keys</span><span class="p">[</span><span class="n">new_key_index</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_vals</span><span class="p">[</span><span class="n">new_key_index</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Using wrong dataset pattern &#39;</span><span class="si">%s</span><span class="s">&#39; on &#39;</span><span class="si">%s</span><span class="s">&#39;!&quot;</span>
                        <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_pattern</span><span class="p">,</span><span class="n">current_dataset</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dataset_pattern</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">results_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">performance</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">results_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">performance</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">result_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c">#Store meta data</span>
        <span class="n">BaseDataset</span><span class="o">.</span><span class="n">store_meta_data</span><span class="p">(</span><span class="n">result_dir</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BinaryClassificationDataset.add_split"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.add_split">[docs]</a>    <span class="k">def</span> <span class="nf">add_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">performance</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">split</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">run</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a split to this dataset</span>

<span class="sd">        The method expects the following parameters:</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            :performance:</span>
<span class="sd">                dictionary of performance measures</span>

<span class="sd">            :train:</span>
<span class="sd">                If train is True, this sample has already been used for training.</span>

<span class="sd">            :split:</span>
<span class="sd">                The number of the split this sample belongs to.</span>

<span class="sd">                (*optional, default: 0*)</span>

<span class="sd">            :run:</span>
<span class="sd">                The run number this performance belongs to.</span>

<span class="sd">                (*optional, default: 0*)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">train</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s">&quot;train_test&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">split</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s">&quot;splits&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s">&quot;splits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">split</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">run</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s">&quot;runs&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s">&quot;runs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">run</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">key</span> <span class="o">=</span>  <span class="p">(</span><span class="n">run</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="s">&quot;train&quot;</span> <span class="k">if</span> <span class="n">train</span> <span class="k">else</span> <span class="s">&quot;test&quot;</span><span class="p">)</span>
        <span class="n">performance</span><span class="p">[</span><span class="s">&quot;__Key_Run__&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">run</span>
        <span class="n">performance</span><span class="p">[</span><span class="s">&quot;__Key_Fold__&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">split</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">performance</span><span class="p">[</span><span class="s">&quot;__Run__&quot;</span><span class="p">]</span><span class="o">=</span><span class="s">&quot;Run_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">run</span><span class="p">)</span>
        <span class="n">performance</span><span class="p">[</span><span class="s">&quot;__Split__&quot;</span><span class="p">]</span><span class="o">=</span><span class="s">&quot;__Split_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">performance</span>
</div>
<div class="viewcode-block" id="BinaryClassificationDataset.merge_splits"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.merge_splits">[docs]</a>    <span class="k">def</span> <span class="nf">merge_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Replace performances of different splits by just one performance value</span>

<span class="sd">        Performances of confusion matrix metrics are calculated by summing</span>
<span class="sd">        up the confusion matrix entries.</span>
<span class="sd">        The other metrics are averaged.</span>

<span class="sd">        This method is the preparation of the merge_performance method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">temp_data</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">new_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">temp_data</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">new_key</span><span class="p">):</span>
                <span class="n">temp_data</span><span class="p">[</span><span class="n">new_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">temp_data</span><span class="p">[</span><span class="n">new_key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">temp_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_performance</span><span class="p">(</span><span class="n">temp_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="BinaryClassificationDataset.merge_performance"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.merge_performance">[docs]</a>    <span class="k">def</span> <span class="nf">merge_performance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Replace performances of different splits by just one performance value</span>

<span class="sd">        Performances of confusion matrix metrics are calculated by summing</span>
<span class="sd">        up the confusion matrix entries.</span>
<span class="sd">        The other metrics are averaged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TP</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">TN</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">FP</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">FN</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">P</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="n">N</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="n">train_TP</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">train_TN</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">train_FP</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">train_FN</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">train_P</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="n">train_N</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_list</span><span class="p">:</span>
            <span class="n">TP</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;True_positives&quot;</span><span class="p">]</span>
            <span class="n">TN</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;True_negatives&quot;</span><span class="p">]</span>
            <span class="n">FP</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;False_positives&quot;</span><span class="p">]</span>
            <span class="n">FN</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;False_negatives&quot;</span><span class="p">]</span>
            <span class="n">P</span>  <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;Positives&quot;</span><span class="p">]</span>
            <span class="n">N</span>  <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;Negatives&quot;</span><span class="p">]</span>
            <span class="n">train_TP</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;train_True_positives&quot;</span><span class="p">]</span>
            <span class="n">train_TN</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;train_True_negatives&quot;</span><span class="p">]</span>
            <span class="n">train_FP</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;train_False_positives&quot;</span><span class="p">]</span>
            <span class="n">train_FN</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;train_False_negatives&quot;</span><span class="p">]</span>
            <span class="n">train_P</span>  <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;train_Positives&quot;</span><span class="p">]</span>
            <span class="n">train_N</span>  <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="s">&quot;train_Negatives&quot;</span><span class="p">]</span>
        <span class="n">old_p_keys</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">new_p_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">weight</span>     <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">calculate_confusion_metrics</span><span class="p">(</span><span class="n">new_p_dict</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="n">TP</span><span class="p">,</span><span class="n">FP</span><span class="p">,</span><span class="n">FN</span><span class="p">,</span><span class="n">TN</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">calculate_confusion_metrics</span><span class="p">(</span><span class="n">new_p_dict</span><span class="p">,</span><span class="s">&quot;train_&quot;</span><span class="p">,</span><span class="n">train_TP</span><span class="p">,</span><span class="n">train_FP</span><span class="p">,</span><span class="n">train_FN</span><span class="p">,</span><span class="n">train_TN</span><span class="p">,</span><span class="n">train_P</span><span class="p">,</span><span class="n">train_N</span><span class="p">,</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">new_p_dict</span><span class="p">[</span><span class="s">&quot;__Key_Fold__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">new_p_dict</span><span class="p">[</span><span class="s">&quot;__Split__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Split_1&quot;</span>
        <span class="n">new_p_dict</span><span class="p">[</span><span class="s">&quot;__Key_Run__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&quot;__Key_Run__&quot;</span><span class="p">]</span>
        <span class="n">new_p_dict</span><span class="p">[</span><span class="s">&quot;__Run__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&quot;__Run__&quot;</span><span class="p">]</span>
        <span class="n">new_p_keys</span> <span class="o">=</span> <span class="n">new_p_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">old_p_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">new_p_keys</span><span class="p">:</span>
                <span class="n">value_list</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_list</span><span class="p">:</span>
                    <span class="n">value_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="nb">str</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span><span class="s">&quot;__Key_Fold__&quot;</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&quot;~~Num_Retained_Features~~&quot;</span><span class="p">):</span>
                    <span class="n">new_p_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">value_list</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&quot;~~Num_Retained_Features~~&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s">&#39;unknown&#39;</span> <span class="ow">in</span> <span class="n">value_list</span><span class="p">:</span>
                        <span class="n">new_p_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_p_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">value_list</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Unknown performance entry:</span><span class="si">%s</span><span class="s">!&quot;</span><span class="o">%</span><span class="n">key</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">)</span>
                    <span class="n">new_p_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_p_dict</span>
</div>
<div class="viewcode-block" id="BinaryClassificationDataset.get_average_performance"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.get_average_performance">[docs]</a>    <span class="k">def</span> <span class="nf">get_average_performance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the average performance for the given metric &quot;&quot;&quot;</span>
        <span class="n">metric_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">itervalues</span><span class="p">():</span>
            <span class="n">metric_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">metric</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">metric_values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric_values</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BinaryClassificationDataset.get_performance_std"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.get_performance_std">[docs]</a>    <span class="k">def</span> <span class="nf">get_performance_std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the average performance for the given metric &quot;&quot;&quot;</span>
        <span class="n">metric_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">itervalues</span><span class="p">():</span>
            <span class="n">metric_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">metric</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">metric_values</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BinaryClassificationDataset.get_unified_confusion_matrix_performance"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.get_unified_confusion_matrix_performance">[docs]</a>    <span class="k">def</span> <span class="nf">get_unified_confusion_matrix_performance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Confusion metrics from the splits altogether &quot;&quot;&quot;</span>
        <span class="n">metric_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">itervalues</span><span class="p">():</span>
            <span class="n">metric_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">metric</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">metric_values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric_values</span><span class="p">)</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.calculate_metrics"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.calculate_metrics">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_metrics</span><span class="p">(</span><span class="n">classification_results</span><span class="p">,</span><span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                          <span class="n">invert_classification</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                          <span class="n">ir_class</span><span class="o">=</span><span class="s">&quot;Target&quot;</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="n">loss_restriction</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span><span class="n">time_periods</span><span class="o">=</span><span class="p">[],</span>
                          <span class="n">calc_AUC</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">calc_loss</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                          <span class="n">weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">save_roc_points</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                          <span class="n">decision_boundary</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate performance measures from the given classifications</span>

<span class="sd">        :Returns: metricdict and the ROC points if save_roc_point is True</span>

<span class="sd">        .. todo:: simplify loss metrics, mutual information and AUC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># metric initializations</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="n">metricdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="c">#{&quot;TP&quot;:0,&quot;FP&quot;:0,&quot;TN&quot;:0,&quot;FN&quot;:0}</span>
        <span class="c"># loss values are collected for each class</span>
        <span class="c"># there are numerous different losses</span>
        <span class="n">loss_dict</span><span class="o">=</span><span class="n">metricdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">prediction_vector</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="n">classification_results</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sec_class</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">label</span><span class="o">==</span><span class="n">ir_class</span><span class="p">:</span>
                <span class="n">sec_class</span> <span class="o">=</span> <span class="n">label</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="o">==</span><span class="n">ir_class</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">label</span><span class="o">==</span><span class="n">sec_class</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Binary metrics &quot;</span> \
                        <span class="s">&quot;require exactly two classes. At least &quot;</span> \
                        <span class="s">&quot;three are used:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ir_class</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="s">&quot; (ir_class), &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sec_class</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="s">&quot; (non_ir_class), &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="s">&quot; (occured true label), &quot;</span> <span class="o">+</span> \
                        <span class="nb">str</span><span class="p">(</span><span class="n">prediction_vector</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="s">&quot; (prediction vector label)! </span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span>\
                        <span class="s">&quot;Did you specify the ir_class in your sink node?</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span>\
                        <span class="s">&quot;Replacing the ir_class by: &quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;.&quot;</span><span class="p">)</span>
                <span class="n">ir_class</span> <span class="o">=</span> <span class="n">label</span>
            <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">update_confusion_matrix</span><span class="p">(</span><span class="n">prediction_vector</span><span class="p">,</span>
                                         <span class="n">label</span><span class="p">,</span><span class="n">calc_soft_metrics</span><span class="o">=</span><span class="n">calc_soft_metrics</span><span class="p">,</span>
                                         <span class="n">ir_class</span><span class="o">=</span><span class="n">ir_class</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="n">sec_class</span><span class="p">,</span>
                                         <span class="n">confusion_matrix</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span>
                                         <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">calc_loss</span><span class="p">:</span>
                <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">update_loss_values</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">=</span><span class="n">prediction_vector</span><span class="p">,</span>
                                    <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                                    <span class="n">ir_class</span><span class="o">=</span><span class="n">ir_class</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="n">sec_class</span><span class="p">,</span>
                                    <span class="n">loss_dict</span><span class="o">=</span><span class="n">loss_dict</span><span class="p">,</span>
                                    <span class="n">loss_restriction</span><span class="o">=</span><span class="n">loss_restriction</span><span class="p">)</span>

        <span class="n">P</span> <span class="o">=</span> <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;True_positives&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">metrics</span><span class="p">[</span><span class="s">&quot;False_negatives&quot;</span><span class="p">]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;True_negatives&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">metrics</span><span class="p">[</span><span class="s">&quot;False_positives&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">calc_soft_metrics</span><span class="p">:</span>
            <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;soft_&quot;</span><span class="p">,</span><span class="s">&quot;pol_&quot;</span><span class="p">,</span><span class="s">&quot;k_&quot;</span><span class="p">]</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;k_True_negatives&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span> <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;k_False_positives&quot;</span><span class="p">])</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;k_False_negatives&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="n">metrics</span><span class="p">[</span><span class="s">&quot;k_True_positives&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">]</span>

        <span class="c">### Confusion matrix metrics</span>
        <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">prefixes</span><span class="p">:</span>
            <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">calculate_confusion_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">P</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>

        <span class="c">### Mutual information ###</span>
        <span class="c"># Mutual information is also a confusion matrix metric but makes no</span>
        <span class="c"># sense for soft metrics</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># Add mutual information between classifier output Y and the target</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Mutual_information&quot;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span>
                                       <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;True_negatives&quot;</span><span class="p">],</span>
                                       <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;False_negatives&quot;</span><span class="p">],</span>
                                       <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;True_positives&quot;</span><span class="p">],</span>
                                       <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;False_positives&quot;</span><span class="p">])</span>
            <span class="c"># Add normalized mutual information (a perfect classifier would achieve</span>
            <span class="c"># metric 1)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Normalized_mutual_information&quot;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">normalized_mutual_information</span><span class="p">(</span>
                                                  <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;True_negatives&quot;</span><span class="p">],</span>
                                                  <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;False_negatives&quot;</span><span class="p">],</span>
                                                  <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;True_positives&quot;</span><span class="p">],</span>
                                                  <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;False_positives&quot;</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Mutual Information could not be calculated!&quot;</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Mutual_information&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Normalized_mutual_information&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c">## Get AUC and ROC_points</span>
        <span class="c"># test if classification_outcome has prediction (float, score)</span>
        <span class="n">ROC_points</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">classification_results</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">calc_AUC</span><span class="p">:</span>
            <span class="n">AUC</span><span class="p">,</span> <span class="n">ROC_points</span> <span class="o">=</span> <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">calculate_AUC</span><span class="p">(</span><span class="n">classification_results</span><span class="p">,</span>
                                             <span class="n">ir_class</span><span class="o">=</span><span class="n">ir_class</span><span class="p">,</span>
                                             <span class="n">save_roc_points</span><span class="o">=</span><span class="n">save_roc_points</span><span class="p">,</span>
                                             <span class="n">performance</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span>
                                             <span class="n">inverse_ordering</span><span class="o">=</span><span class="n">invert_classification</span><span class="p">)</span>
            <span class="c"># If classification missed the ordering of the two classes or</span>
            <span class="c"># used information in the wrong way prediction should be switched.</span>
            <span class="c"># This results in the *inverse* AUC.</span>
            <span class="k">if</span> <span class="n">AUC</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="n">AUC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">AUC</span>
                <span class="k">if</span> <span class="n">AUC</span><span class="o">&gt;</span><span class="mf">0.6</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;AUC had to be inverted! Check this!&quot;</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;AUC&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">AUC</span>

        <span class="c">### Extract meta metrics from the predictor ###</span>
        <span class="c"># set basic important predictor metrics for default</span>
        <span class="c">#metrics[&quot;~~Num_Retained_Features~~&quot;] = numpy.inf</span>
        <span class="c">#metrics[&quot;~~Solver_Iterations~~&quot;] = numpy.Inf</span>
        <span class="c">#metrics[&quot;~~Classifier_Converged~~&quot;] = True</span>
        <span class="c"># Classifier information should be saved in the parameter</span>
        <span class="c"># &#39;classifier_information&#39;!!!</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">classifier_information</span> <span class="o">=</span> <span class="n">classification_results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span><span class="n">classifier_information</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">classifier_information</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c">### Time metrics ###</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c"># the first measured time can be inaccurate due to</span>
            <span class="c"># initialization procedures performed in the first executions</span>
            <span class="n">time_periods</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Time (average)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">1000</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span> <span class="o">/</span> \
                                                        <span class="nb">len</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Time (maximal)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">1000</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span>

        <span class="c">### Loss metrics ###</span>
        <span class="k">if</span> <span class="n">calc_loss</span><span class="p">:</span>
            <span class="c"># initialization #</span>
            <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="n">P</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">P</span><span class="o">=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">N</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">N</span><span class="o">=</span><span class="mi">1</span>
            <span class="c"># unbalanced losses</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_L1_SVM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L1_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                      <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L1_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_L2_SVM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L2_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                      <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L2_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_L1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L1_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                  <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L1_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_L2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L2_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                  <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L2_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_L1_RMM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                      <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_L2_RMM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                      <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_restr_L1_SVM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                            <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_restr_L2_SVM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                            <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_restr_L1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                        <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_restr_L2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                        <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_restr_L1_RMM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                            <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_restr_L2_RMM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                                            <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">n</span>
            <span class="c"># balanced losses</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_L1_SVM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L1_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                               <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L1_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_L2_SVM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L2_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                               <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L2_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_L1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L1_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                           <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L1_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_L2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L2_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                           <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L2_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_L1_RMM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                               <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_L2_RMM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                               <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_restr_L1_SVM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                                     <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_restr_L2_SVM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                                     <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_restr_L1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                                 <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_restr_L2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                                 <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_restr_L1_RMM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                                     <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;loss_balanced_restr_L2_RMM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">N</span> <span class="o">+</span> \
                                                     <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss_restr&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

        <span class="k">if</span> <span class="n">save_roc_points</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">metrics</span><span class="p">,</span> <span class="n">ROC_points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">metrics</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.update_confusion_matrix"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.update_confusion_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">update_confusion_matrix</span><span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span><span class="n">calc_soft_metrics</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                <span class="n">ir_class</span><span class="o">=</span><span class="s">&#39;Target&#39;</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="s">&#39;Standard&#39;</span><span class="p">,</span>
                                <span class="n">confusion_matrix</span><span class="o">=</span><span class="n">metricdict</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
                                <span class="n">decision_boundary</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the change in the 4 basic metrics: TP, FP, TN, FN</span>

<span class="sd">        +--------------+----+-----+</span>
<span class="sd">        | class|guess  | ir | sec |</span>
<span class="sd">        +==============+====+=====+</span>
<span class="sd">        | ir_class     | TP | FN  |</span>
<span class="sd">        +--------------+----+-----+</span>
<span class="sd">        | sec_class    | FP | TN  |</span>
<span class="sd">        +--------------+----+-----+</span>

<span class="sd">        The change is directly written into the confusion matrix dictionary.</span>

<span class="sd">        :Returns: confusion_matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_label</span> <span class="o">=</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="c"># prepare prediction in case of no mapping beforehand</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span>
        <span class="k">if</span> <span class="n">decision_boundary</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span> <span class="c"># if mapping was before, this should be around 0.5</span>
            <span class="c"># ir_class&gt;0; sec_class&lt;0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p_label</span> <span class="o">==</span> <span class="n">ir_class</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">prediction</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="n">p_label</span> <span class="o">==</span> <span class="n">sec_class</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">prediction</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">prediction</span><span class="o">*=-</span><span class="mf">1.0</span>
            <span class="k">if</span> <span class="n">p_label</span> <span class="o">==</span> <span class="n">sec_class</span><span class="p">:</span>
                <span class="n">prediction</span><span class="o">*=-</span><span class="mf">1.0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p_label</span> <span class="o">==</span> <span class="n">label</span><span class="p">:</span> <span class="c"># negative values in case of wrong classification</span>
                <span class="n">prediction</span><span class="o">*=-</span><span class="mf">1.0</span>


        <span class="c"># true positive</span>
        <span class="k">if</span> <span class="n">p_label</span> <span class="o">==</span> <span class="n">ir_class</span> <span class="ow">and</span> <span class="n">p_label</span> <span class="o">==</span> <span class="n">label</span><span class="p">:</span>
            <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;True_positives&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">calc_soft_metrics</span><span class="p">:</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;soft_True_positives&quot;</span><span class="p">]</span> <span class="o">+=</span> \
                        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span><span class="p">,</span>
                                  <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">)</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;pol_True_positives&quot;</span><span class="p">]</span> <span class="o">+=</span> \
                        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">pol</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span><span class="p">,</span>
                                <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">)</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;k_True_positives&quot;</span><span class="p">]</span> <span class="o">+=</span> \
                        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">k_sig</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span>
                                <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">,</span>
                                <span class="n">scaling</span><span class="o">=</span><span class="n">scaling</span><span class="p">)</span>
        <span class="c"># false positive</span>
        <span class="k">elif</span> <span class="n">p_label</span> <span class="o">==</span> <span class="n">ir_class</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">p_label</span> <span class="o">==</span> <span class="n">label</span><span class="p">):</span>
            <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;False_positives&quot;</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">calc_soft_metrics</span><span class="p">:</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;soft_False_positives&quot;</span><span class="p">]</span> <span class="o">+=</span> \
                        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span><span class="p">,</span>
                                  <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">)</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;pol_False_positives&quot;</span><span class="p">]</span> <span class="o">+=</span> \
                        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">pol</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span><span class="p">,</span>
                                <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">)</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;k_False_positives&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">-</span> \
                         <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">k_sig</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span>
                                <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">,</span>
                                <span class="n">scaling</span><span class="o">=</span><span class="n">scaling</span><span class="p">)</span>
        <span class="c"># false negative</span>
        <span class="k">elif</span> <span class="n">p_label</span> <span class="o">==</span> <span class="n">sec_class</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">p_label</span> <span class="o">==</span> <span class="n">label</span><span class="p">):</span>
            <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;False_negatives&quot;</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">calc_soft_metrics</span><span class="p">:</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;soft_False_negatives&quot;</span><span class="p">]</span> <span class="o">+=</span> \
                        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span><span class="p">,</span>
                                  <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">)</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;pol_False_negatives&quot;</span><span class="p">]</span> <span class="o">+=</span> \
                        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">pol</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span><span class="p">,</span>
                                <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">)</span>
                <span class="c">#prediction negative/wrong--&gt; low value added</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;k_True_positives&quot;</span><span class="p">]</span> <span class="o">+=</span> \
                        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">k_sig</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span>
                                <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">,</span>
                                <span class="n">scaling</span><span class="o">=</span><span class="n">scaling</span><span class="p">)</span>
        <span class="c"># true negative</span>
        <span class="k">elif</span> <span class="n">p_label</span> <span class="o">==</span> <span class="n">sec_class</span> <span class="ow">and</span> <span class="n">p_label</span> <span class="o">==</span> <span class="n">label</span><span class="p">:</span>
            <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;True_negatives&quot;</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">calc_soft_metrics</span><span class="p">:</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;soft_True_negatives&quot;</span><span class="p">]</span> <span class="o">+=</span> \
                        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span><span class="p">,</span>
                                  <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">)</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;pol_True_negatives&quot;</span><span class="p">]</span> <span class="o">+=</span> \
                        <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">pol</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span><span class="p">,</span>
                                <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">)</span>
                <span class="c"># prediction is positive --&gt; low value subtracted--&gt; nearly 1</span>
                <span class="n">confusion_matrix</span><span class="p">[</span><span class="s">&quot;k_False_positives&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">-</span> \
                         <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">k_sig</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span>
                                <span class="n">decision_boundary</span><span class="o">=</span><span class="n">decision_boundary</span><span class="p">,</span>
                                <span class="n">scaling</span><span class="o">=</span><span class="n">scaling</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Updating confusion matrix &quot;</span> \
                        <span class="s">&quot;requires exactly two classes. At least &quot;</span> \
                        <span class="s">&quot;three are used:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ir_class</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="s">&quot; (ir_class), &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sec_class</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="s">&quot; (non_ir_class), &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="s">&quot; (correct label), &quot;</span> <span class="o">+</span> \
                        <span class="nb">str</span><span class="p">(</span><span class="n">classification_vector</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="s">&quot; (classification)! </span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span>\
                        <span class="s">&quot;Did you specify the ir_class in your sink node?&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">confusion_matrix</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.scale"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">decision_boundary</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Scales the prediction output to [0,1] by simple cutting</span>
<span class="sd">        to show there reliability</span>
<span class="sd">        contribution in the prediction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">decision_boundary</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="o">-</span><span class="n">value</span>
            <span class="k">if</span> <span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">output</span>
        <span class="k">else</span><span class="p">:</span> <span class="c">#probabilistic output assumed</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">&gt;</span><span class="n">decision_boundary</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">value</span>
            <span class="k">if</span> <span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">output</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.sig"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.sig">[docs]</a>    <span class="k">def</span> <span class="nf">sig</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">decision_boundary</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Scales the prediction output to [0,1] SMOOTH with a sinusoid function</span>
<span class="sd">        to show there reliability</span>
<span class="sd">        contribution in the prediction.</span>

<span class="sd">        Therefore it uses the sinusoid sigmoid function</span>

<span class="sd">        .. math::  0.5\\cdot (1-cos(value\\cdot \\pi))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="o">-</span><span class="n">value</span>
        <span class="k">if</span> <span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">output</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">output</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.pol"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.pol">[docs]</a>    <span class="k">def</span> <span class="nf">pol</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">decision_boundary</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Scales the prediction output to [0,1] SMOOTH with a polynomial function</span>
<span class="sd">        to show there reliability</span>
<span class="sd">        contribution in the prediction.</span>

<span class="sd">        Therefore it uses the polynomial sigmoid function</span>

<span class="sd">        .. math:: value^2 (3-2 \\cdot value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">value</span>
        <span class="k">if</span> <span class="n">output</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.k_sig"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.k_sig">[docs]</a>    <span class="k">def</span> <span class="nf">k_sig</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">decision_boundary</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Scaling as in Keerthi 2006 for smooth target function</span>

<span class="sd">        &quot;An efficient method for gradient-based adaptation of</span>
<span class="sd">        hyperparameters in SVM models&quot;</span>
<span class="sd">        Keerthi, S. Sathiya; Sindhwani, Vikas; Chapelle, Olivier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">decision_boundary</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span> <span class="c"># no mapping needed, due to prob-fit</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">scaling</span><span class="o">*</span><span class="n">value</span><span class="p">))</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.update_loss_values"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.update_loss_values">[docs]</a>    <span class="k">def</span> <span class="nf">update_loss_values</span><span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span>
                           <span class="n">ir_class</span><span class="o">=</span><span class="s">&quot;Target&quot;</span><span class="p">,</span> <span class="n">sec_class</span><span class="o">=</span><span class="s">&quot;Standard&quot;</span><span class="p">,</span>
                           <span class="n">loss_dict</span><span class="o">=</span><span class="n">metricdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
                           <span class="n">loss_restriction</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate classifier loss terms on test data</span>

<span class="sd">        Different classifiers mapping the ir_class to 1 and the other</span>
<span class="sd">        class to -1 try to minimize a loss term in the classification.</span>
<span class="sd">        For some used loss terms of least squares classifiers and SVMs</span>
<span class="sd">        the corresponding value is calculated as a metric to be later on used</span>
<span class="sd">        for optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span><span class="o">==</span><span class="n">ir_class</span><span class="p">:</span>
            <span class="n">prediction</span> <span class="o">=</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prediction</span> <span class="o">=</span> <span class="o">-</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">prediction</span>
        <span class="k">if</span> <span class="n">label</span> <span class="o">==</span><span class="n">ir_class</span><span class="p">:</span>
            <span class="n">i</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span><span class="o">=</span><span class="mi">0</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L1_loss&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">prediction</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L2_loss&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prediction</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L1_loss_restr&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">prediction</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">loss_restriction</span><span class="p">)</span>
            <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;L2_loss_restr&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">prediction</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">loss_restriction</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span><span class="n">range</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>

            <span class="k">if</span> <span class="n">prediction</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">:</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">prediction</span><span class="o">-</span><span class="n">R</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prediction</span><span class="o">-</span><span class="n">R</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss_restr&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">prediction</span><span class="o">-</span><span class="n">R</span><span class="p">,</span><span class="n">loss_restriction</span><span class="p">)</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss_restr&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">prediction</span><span class="o">-</span><span class="n">R</span><span class="p">,</span><span class="n">loss_restriction</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">elif</span> <span class="n">prediction</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c">#self.RMM_L1_loss += 0</span>
                <span class="c">#self.RMM_L2_loss += 0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L1_loss&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">-</span><span class="n">prediction</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L2_loss&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">prediction</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L1_loss_restr&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">prediction</span><span class="p">,</span><span class="n">loss_restriction</span><span class="p">)</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;SVM_L2_loss_restr&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">prediction</span><span class="p">,</span><span class="n">loss_restriction</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">-</span><span class="n">prediction</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">prediction</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L1_loss_restr&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">prediction</span><span class="p">,</span><span class="n">loss_restriction</span><span class="p">)</span>
                <span class="n">loss_dict</span><span class="p">[</span><span class="s">&quot;RMM_L2_loss_restr&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">prediction</span><span class="p">,</span><span class="n">loss_restriction</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.calculate_confusion_metrics"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.calculate_confusion_metrics">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_confusion_metrics</span><span class="p">(</span><span class="n">performance</span><span class="p">,</span> <span class="n">pre</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                    <span class="n">N</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate each performance metric resulting from the 4 values in the confusion matrix and return it.</span>

<span class="sd">        This helps to use soft metrics, generating the confusion matrix</span>
<span class="sd">        in a different way.</span>

<span class="sd">        .. warning::    Still the number of positive and negative instances</span>
<span class="sd">                        had to be used for the calculation of rates with soft metrics.</span>

<span class="sd">        :Returns: metricdict</span>

<span class="sd">        .. note:: If the input is a metricdict the new calculated entries are added to it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TN</span> <span class="o">=</span> <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;True_negatives&quot;</span><span class="p">]</span>
        <span class="n">TP</span> <span class="o">=</span> <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;True_positives&quot;</span><span class="p">]</span>
        <span class="n">FP</span> <span class="o">=</span> <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;False_positives&quot;</span><span class="p">]</span>
        <span class="n">FN</span> <span class="o">=</span> <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;False_negatives&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">performance</span><span class="p">)</span> <span class="o">==</span> <span class="n">metricdict</span><span class="p">:</span>
            <span class="n">old_p</span> <span class="o">=</span> <span class="n">performance</span>
            <span class="n">performance</span> <span class="o">=</span> <span class="n">metricdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">performance</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">old_p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">TP</span><span class="o">+</span><span class="n">FN</span>
        <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">TN</span><span class="o">+</span><span class="n">FP</span>

        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Positives&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Negatives&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>

        <span class="k">if</span> <span class="n">TP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">TPR</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">PPV</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># sensitivity, recall</span>
            <span class="n">TPR</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">TP</span><span class="o">/</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="c">#(TP+FN) = Num of positive examples</span>
            <span class="c"># positive predictive value, precision</span>
            <span class="n">PPV</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">TP</span><span class="o">/</span><span class="p">(</span><span class="n">TP</span><span class="o">+</span><span class="n">FP</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">TN</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">TNR</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">NPV</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">TNR</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">TN</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c"># specificity #  Num of negative examples</span>
            <span class="n">NPV</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">TN</span><span class="o">/</span><span class="p">(</span><span class="n">TN</span><span class="o">+</span><span class="n">FN</span><span class="p">)</span> <span class="c"># negative predictive value</span>
        <span class="n">FPR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">TNR</span> <span class="c"># 1.0*FP/(TN+FP) # 1-TNR</span>
        <span class="n">FNR</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">TPR</span> <span class="c"># 1.0*FN/(TP+FN) # 1-TPR</span>

        <span class="k">if</span> <span class="n">P</span><span class="o">+</span><span class="n">N</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">accuracy</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">missclassification_rate</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;No examples given for performance calculation!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">accuracy</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">TP</span><span class="o">+</span><span class="n">TN</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="n">P</span><span class="p">)</span> <span class="c"># Num of all examples</span>
            <span class="n">missclassification_rate</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">FP</span><span class="o">+</span><span class="n">FN</span><span class="p">)</span> <span class="o">/</span> \
                                             <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="n">P</span><span class="p">)</span> <span class="c"># s.a.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PPV</span><span class="o">+</span><span class="n">TPR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">F_measure</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">F_measure</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">PPV</span><span class="o">*</span><span class="n">TPR</span><span class="o">/</span><span class="p">(</span><span class="n">PPV</span><span class="o">+</span><span class="n">TPR</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">NPV</span><span class="o">+</span><span class="n">TNR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">F_neg_measure</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">F_neg_measure</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">NPV</span><span class="o">*</span><span class="n">TNR</span><span class="o">/</span><span class="p">(</span><span class="n">NPV</span><span class="o">+</span><span class="n">TNR</span><span class="p">)</span>

        <span class="n">den</span> <span class="o">=</span> <span class="p">(</span><span class="n">TP</span><span class="o">+</span><span class="n">FN</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">TP</span><span class="o">+</span><span class="n">FP</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">TN</span><span class="o">+</span><span class="n">FN</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">TN</span><span class="o">+</span><span class="n">FP</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">den</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">den</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">MCC</span> <span class="o">=</span> <span class="p">(</span><span class="n">TP</span><span class="o">*</span><span class="n">TN</span><span class="o">-</span><span class="n">FP</span><span class="o">*</span><span class="n">FN</span><span class="p">)</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>

        <span class="c"># weighted_F_measure = lambda x: (1+x**2)*PPV*TPR/(x**2*PPV+TPR)</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;True_positive_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">TPR</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;False_positive_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FPR</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;True_negative_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">TNR</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;False_negative_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FNR</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;IR_precision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PPV</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;IR_recall&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">TPR</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;F_measure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F_measure</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Non_IR_F_measure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F_neg_measure</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Non_IR_precision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NPV</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Percent_correct&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">accuracy</span><span class="o">*</span><span class="mi">100</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Percent_incorrect&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">missclassification_rate</span><span class="o">*</span><span class="mi">100</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Weighted_accuracy(&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;)&quot;</span><span class="p">]</span> <span class="o">=</span> \
                                          <span class="n">weight</span> <span class="o">*</span> <span class="n">TPR</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">weight</span><span class="p">)</span><span class="o">*</span><span class="n">TNR</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;ROC-measure&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">TPR</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">TNR</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Balanced_accuracy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">TNR</span> <span class="o">+</span> <span class="n">TPR</span><span class="p">)</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Gmean&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">TPR</span><span class="o">*</span><span class="n">TNR</span><span class="p">))</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Matthews_correlation_coefficient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MCC</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Correct_classified&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">TP</span><span class="o">+</span><span class="n">TN</span>
        <span class="n">performance</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="s">&quot;Wrong_classified&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">FP</span><span class="o">+</span><span class="n">FN</span>
        <span class="k">return</span> <span class="n">performance</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.calculate_AUC"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.calculate_AUC">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_AUC</span><span class="p">(</span><span class="n">classification_outcome</span><span class="p">,</span> <span class="n">ir_class</span><span class="p">,</span> <span class="n">save_roc_points</span><span class="p">,</span>
                            <span class="n">performance</span><span class="p">,</span><span class="n">inverse_ordering</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; AUC and ROC points by an algorithm from Fawcett, &quot;An introduction to ROC analysis&quot;, 2005</span>
<span class="sd">        Also possible would be to calculate the Mann-Whitney-U-Statistik</span>

<span class="sd">        .. math:: \\sum_i^m{\\sum_j^n{S(X_i,Y_i)}} \\text{ with } S(X,Y) = 1 \\text{ if } Y &lt; X\\text{, otherwise } 0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># need sorted list, decreasing by the prediction score</span>
        <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
        <span class="n">sorted_outcome</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">classification_outcome</span><span class="p">,</span>
                                <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="ow">not</span> <span class="n">inverse_ordering</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">performance</span><span class="p">[</span><span class="s">&quot;Positives&quot;</span><span class="p">]</span> <span class="c"># number of True instances</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">performance</span><span class="p">[</span><span class="s">&quot;Negatives&quot;</span><span class="p">]</span> <span class="c"># number of False instances</span>

        <span class="n">FP</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">TP</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">FP_prev</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">TP_prev</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">AUC</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># first, list of roc points, second, the weka-roc-point</span>
        <span class="n">R</span> <span class="o">=</span> <span class="p">([],[(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">),(</span><span class="n">performance</span><span class="p">[</span><span class="s">&quot;False_positive_rate&quot;</span><span class="p">],</span>
                <span class="n">performance</span><span class="p">[</span><span class="s">&quot;True_positive_rate&quot;</span><span class="p">]),(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)])</span>
        <span class="n">axis_change</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">axis_y</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">axis_x</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">prediction_prev</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">&quot;infinity&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_trapezoid_area</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span>
            <span class="n">height_avg</span> <span class="o">=</span> <span class="p">(</span><span class="n">y1</span><span class="o">+</span><span class="n">y2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="k">return</span> <span class="n">base</span> <span class="o">*</span> <span class="n">height_avg</span>

        <span class="k">for</span> <span class="n">classification_outcome</span> <span class="ow">in</span> <span class="n">sorted_outcome</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">classification_outcome</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prediction_prev</span><span class="p">:</span>
                <span class="n">AUC</span> <span class="o">+=</span> <span class="n">_trapezoid_area</span><span class="p">(</span><span class="n">FP</span><span class="p">,</span> <span class="n">FP_prev</span><span class="p">,</span> <span class="n">TP</span><span class="p">,</span> <span class="n">TP_prev</span><span class="p">)</span>
                <span class="n">prediction_prev</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">classification_outcome</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">save_roc_points</span> <span class="ow">and</span> <span class="n">axis_change</span><span class="p">:</span>
                    <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">1.0</span><span class="o">*</span><span class="n">FP_prev</span><span class="o">/</span><span class="n">N</span><span class="p">,</span><span class="mf">1.0</span><span class="o">*</span><span class="n">TP_prev</span><span class="o">/</span><span class="n">P</span><span class="p">))</span>
                    <span class="n">axis_change</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">FP_prev</span> <span class="o">=</span> <span class="n">FP</span>
                <span class="n">TP_prev</span> <span class="o">=</span> <span class="n">TP</span>

            <span class="c"># if actual instance is a true / ir class example</span>
            <span class="k">if</span> <span class="n">classification_outcome</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="n">ir_class</span><span class="p">:</span>
                <span class="n">TP</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">axis_y</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">axis_x</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">axis_change</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">axis_x</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># instance is a false / sec class example</span>
                <span class="n">FP</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">axis_x</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">axis_y</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">axis_change</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">axis_y</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">save_roc_points</span> <span class="ow">and</span> <span class="n">axis_change</span><span class="p">:</span>
            <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">1.0</span><span class="o">*</span><span class="n">FP_prev</span><span class="o">/</span><span class="n">N</span><span class="p">,</span><span class="mf">1.0</span><span class="o">*</span><span class="n">TP_prev</span><span class="o">/</span><span class="n">P</span><span class="p">))</span>

        <span class="n">AUC</span> <span class="o">+=</span> <span class="n">_trapezoid_area</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">FP_prev</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">TP_prev</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">AUC</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">AUC</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">P</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="c"># scale from (P*N) to the unit square</span>
            <span class="k">if</span> <span class="n">save_roc_points</span><span class="p">:</span>
                <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">1.0</span><span class="o">*</span><span class="n">FP</span><span class="o">/</span><span class="n">N</span><span class="p">,</span><span class="mf">1.0</span><span class="o">*</span><span class="n">TP</span><span class="o">/</span><span class="n">P</span><span class="p">))</span> <span class="c"># This is (1,1)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;AUC could no be computed since there are no &quot;</span>
                              <span class="s">&quot;positive examples.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;AUC could no be computed since there are no &quot;</span>
                              <span class="s">&quot;negative examples.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AUC</span><span class="p">,</span> <span class="n">R</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.mutual_information"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.mutual_information">[docs]</a>    <span class="k">def</span> <span class="nf">mutual_information</span><span class="p">(</span><span class="n">TN</span><span class="p">,</span> <span class="n">FN</span><span class="p">,</span> <span class="n">TP</span><span class="p">,</span> <span class="n">FP</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the mutual information metric I(T;Y) = H(T) - H(T|Y)</span>

<span class="sd">        Measures the mutual information between the classifier output Y</span>
<span class="sd">        and the target (the true label T), i.e. how many bits the classifier&#39;s</span>
<span class="sd">        output conveys about the target. H denotes the entropy function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Convert to float</span>
        <span class="n">TN</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">TN</span><span class="p">)</span>
        <span class="n">FN</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">FN</span><span class="p">)</span>
        <span class="n">TP</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span>
        <span class="n">FP</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span> <span class="c"># positive examples</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">FP</span> <span class="o">+</span> <span class="n">TN</span> <span class="c"># negative examples</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">TP</span><span class="o">+</span><span class="n">FP</span><span class="o">+</span><span class="n">TN</span><span class="o">+</span><span class="n">FN</span> <span class="c"># Total number of examples</span>

        <span class="k">def</span> <span class="nf">term</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">:</span> <span class="c"># prediction is positive</span>
                <span class="n">p_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span><span class="p">)</span> <span class="o">/</span> <span class="n">K</span> <span class="c"># ratio of positive predictions</span>
                <span class="k">if</span> <span class="n">p_y</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">p_t_y</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># Doesn&#39;t matter anyway since multiplied with 0</span>
                <span class="k">elif</span> <span class="n">t</span><span class="p">:</span> <span class="c"># actually a positive</span>
                    <span class="n">p_t_y</span> <span class="o">=</span> <span class="n">TP</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span><span class="p">)</span> <span class="c"># ratio of true positives</span>
                <span class="k">else</span><span class="p">:</span> <span class="c"># actually a negative</span>
                    <span class="n">p_t_y</span> <span class="o">=</span> <span class="n">FP</span> <span class="o">/</span> <span class="p">(</span><span class="n">TP</span> <span class="o">+</span> <span class="n">FP</span><span class="p">)</span><span class="c"># ratio of false positives</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># prediction is negative</span>
                <span class="n">p_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">TN</span> <span class="o">+</span> <span class="n">FN</span><span class="p">)</span> <span class="o">/</span> <span class="n">K</span> <span class="c"># ratio of negative predictions</span>
                <span class="k">if</span> <span class="n">p_y</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">p_t_y</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># Doesn&#39;t matter anyway since multiplied with 0</span>
                <span class="k">elif</span> <span class="n">t</span><span class="p">:</span> <span class="c"># actually a positive</span>
                    <span class="n">p_t_y</span> <span class="o">=</span> <span class="n">FN</span> <span class="o">/</span> <span class="p">(</span><span class="n">TN</span> <span class="o">+</span> <span class="n">FN</span><span class="p">)</span> <span class="c"># ratio of false negatives</span>
                <span class="k">else</span><span class="p">:</span> <span class="c"># actually a negative</span>
                    <span class="n">p_t_y</span> <span class="o">=</span> <span class="n">TN</span> <span class="o">/</span> <span class="p">(</span><span class="n">TN</span> <span class="o">+</span> <span class="n">FN</span><span class="p">)</span> <span class="c"># ratio of true negatives</span>

            <span class="k">if</span> <span class="n">t</span><span class="p">:</span> <span class="c"># Actually a positive</span>
                <span class="n">p_t</span> <span class="o">=</span>  <span class="n">P</span> <span class="o">/</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="n">N</span><span class="p">)</span> <span class="c"># ratio of positive examples</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># Actually a negative</span>
                <span class="n">p_t</span> <span class="o">=</span>  <span class="n">N</span> <span class="o">/</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="n">N</span><span class="p">)</span> <span class="c"># ratio of positive examples</span>

            <span class="k">if</span> <span class="n">p_t</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span> <span class="c"># We don&#39;t have any examples for this class (should not happen)</span>
                <span class="c"># There is no uncertainty about class and thus no information</span>
                <span class="c"># gain. We return 0</span>
                <span class="k">return</span> <span class="mf">0.0</span>
            <span class="k">elif</span> <span class="n">p_t_y</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="c"># We set 0*-inf = 0</span>
                <span class="k">return</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">p_y</span><span class="o">*</span><span class="n">p_t_y</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p_t_y</span><span class="o">/</span><span class="n">p_t</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">term</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">])</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BinaryClassificationDataset.normalized_mutual_information"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.BinaryClassificationDataset.normalized_mutual_information">[docs]</a>    <span class="k">def</span> <span class="nf">normalized_mutual_information</span><span class="p">(</span><span class="n">TN</span><span class="p">,</span> <span class="n">FN</span><span class="p">,</span> <span class="n">TP</span><span class="p">,</span> <span class="n">FP</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Normalized mutual information IN(T;Y) = (H(T) - H(T|Y))/H(T)</span>

<span class="sd">        This metric has the property that an optimal classifier will always get</span>
<span class="sd">        value 1 while any kind of random classifier (those on the diagonal in ROC</span>
<span class="sd">        space) get value 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">TN</span><span class="p">,</span> <span class="n">FN</span><span class="p">,</span> <span class="n">TP</span><span class="p">,</span> <span class="n">FP</span><span class="p">)</span> <span class="o">/</span> \
               <span class="n">BinaryClassificationDataset</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">TN</span> <span class="o">+</span> <span class="n">FP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TP</span> <span class="o">+</span> <span class="n">FN</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="MultinomialClassificationDataset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.MultinomialClassificationDataset">[docs]</a><span class="k">class</span> <span class="nc">MultinomialClassificationDataset</span><span class="p">(</span><span class="n">BinaryClassificationDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Handle and store multiclass classification performance measures</span>

<span class="sd">    **Metrics**</span>

<span class="sd">    Balanced accuracy, accuracy and weighted accuracy are calculated as</span>
<span class="sd">    in the Binary case.</span>

<span class="sd">        :Accuracy: Number of correct classifications devided by total</span>
<span class="sd">                   number of classified samples</span>

<span class="sd">        :Balanced_accuracy: Mean of True positive rates for all classes</span>

<span class="sd">        :Weighted_accuracy:</span>
<span class="sd">            Weighted sum of True positive rates for all classes,</span>
<span class="sd">            using the `weight` parameter</span>

<span class="sd">        :Matthews_correlation_coefficient:</span>
<span class="sd">            Pearson’s correlation coefficient between classification</span>
<span class="sd">            and true label matrix.</span>

<span class="sd">            - Paper: Comparing two K-category assignments by a K-category correlation coefficient</span>
<span class="sd">            - Author: J. Gorodkin</span>
<span class="sd">            - Page: 369</span>
<span class="sd">            - Webpage: http://dx.doi.org/10.1016/j.compbiolchem.2004.09.006</span>

<span class="sd">        :micro/macro_average_F_measure:</span>

<span class="sd">            - Paper: A Study on Threshold Selection for Multi-label Classification</span>
<span class="sd">            - Author: Rong-En Fan and Chih-Jen Lin</span>
<span class="sd">            - Page: 4</span>

<span class="sd">    .. todo:: Integrate Mututal information, other micro/macro averages and</span>
<span class="sd">              other metrics.</span>

<span class="sd">    :Author: Mario Michael Krell</span>
<span class="sd">    :Created: 2012/11/02</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="MultinomialClassificationDataset.calculate_metrics"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.MultinomialClassificationDataset.calculate_metrics">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_metrics</span><span class="p">(</span><span class="n">classification_results</span><span class="p">,</span>
                          <span class="n">time_periods</span><span class="o">=</span><span class="p">[],</span>
                          <span class="n">weight</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate performance measures from the given classifications &quot;&quot;&quot;</span>
        <span class="c"># metric initializations</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="n">metricdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">classes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">prediction_vector</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="n">classification_results</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
                <span class="n">classes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">prediction_vector</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">):</span>
                <span class="n">classes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prediction_vector</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="n">MultinomialClassificationDataset</span><span class="o">.</span><span class="n">update_confusion_matrix</span><span class="p">(</span><span class="n">prediction_vector</span><span class="p">,</span>
                                         <span class="n">label</span><span class="p">,</span><span class="n">confusion_matrix</span><span class="o">=</span><span class="n">metrics</span><span class="p">)</span>
        <span class="n">MultinomialClassificationDataset</span><span class="o">.</span><span class="n">calculate_confusion_metrics</span><span class="p">(</span>
                                                            <span class="n">performance</span><span class="o">=</span><span class="n">metrics</span><span class="p">,</span>
                                                            <span class="n">classes</span><span class="o">=</span><span class="n">classes</span><span class="p">,</span>
                                                            <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
        <span class="c">### Extract meta metrics from the predictor ### (copy from BinaryClassificationSink)</span>
        <span class="c"># set basic important predictor metrics for default</span>
        <span class="c">#metrics[&quot;~~Num_Retained_Features~~&quot;] = numpy.inf</span>
        <span class="c">#metrics[&quot;~~Solver_Iterations~~&quot;] = numpy.Inf</span>
        <span class="c">#metrics[&quot;~~Classifier_Converged~~&quot;] = True</span>
        <span class="c"># Classifier information should be saved in the parameter</span>
        <span class="c"># &#39;classifier_information&#39;!!!</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">classifier_information</span> <span class="o">=</span> <span class="n">classification_results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span><span class="n">classifier_information</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">classifier_information</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c">### Time metrics ###</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c"># the first measured time can be inaccurate due to</span>
            <span class="c"># initialization procedures performed in the first executions</span>
            <span class="n">time_periods</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Time (average)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">1000</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span> <span class="o">/</span> \
                                                        <span class="nb">len</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Time (maximal)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">1000</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">metrics</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="MultinomialClassificationDataset.update_confusion_matrix"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.MultinomialClassificationDataset.update_confusion_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">update_confusion_matrix</span><span class="p">(</span><span class="n">classification_vector</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span>
                                <span class="n">confusion_matrix</span><span class="o">=</span><span class="n">metricdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the change in the confusion matrix</span>

<span class="sd">        +--------------+-----------+-----------+</span>
<span class="sd">        | class|guess  | c1        | c2        |</span>
<span class="sd">        +==============+===========+===========+</span>
<span class="sd">        | c1           | T:c1_P:c1 | T:c1_P:c2 |</span>
<span class="sd">        +--------------+-----------+-----------+</span>
<span class="sd">        | c2           | T:c2_P:c1 | T:c2_P:c2 |</span>
<span class="sd">        +--------------+-----------+-----------+</span>

<span class="sd">        The change is directly written into the confusion matrix dictionary.</span>

<span class="sd">        :Returns: confusion_matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_label</span> <span class="o">=</span> <span class="n">classification_vector</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">metric_str</span><span class="o">=</span><span class="s">&quot;T:&quot;</span><span class="o">+</span><span class="n">label</span><span class="o">+</span><span class="s">&quot;_P:&quot;</span><span class="o">+</span><span class="n">p_label</span>
        <span class="n">confusion_matrix</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">confusion_matrix</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="MultinomialClassificationDataset.calculate_confusion_metrics"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.MultinomialClassificationDataset.calculate_confusion_metrics">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_confusion_metrics</span><span class="p">(</span><span class="n">performance</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate metrics of multinomial confusion matrix &quot;&quot;&quot;</span>
        <span class="n">num_class_samples</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">num_class_predictions</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">weight</span><span class="o">==</span><span class="mf">0.5</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
                <span class="n">weight</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span>

        <span class="n">cm</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">truth</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">classes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">prediction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">classes</span><span class="p">):</span>
                <span class="n">metric_str</span><span class="o">=</span><span class="s">&quot;T:&quot;</span><span class="o">+</span><span class="n">truth</span><span class="o">+</span><span class="s">&quot;_P:&quot;</span><span class="o">+</span><span class="n">prediction</span>
                <span class="n">num_samples</span> <span class="o">+=</span> <span class="n">performance</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span>
                <span class="n">num_class_samples</span><span class="p">[</span><span class="n">truth</span><span class="p">]</span> <span class="o">+=</span> <span class="n">performance</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span>
                <span class="n">num_class_predictions</span><span class="p">[</span><span class="n">prediction</span><span class="p">]</span> <span class="o">+=</span> <span class="n">performance</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span>
                <span class="n">cm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">performance</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_class_samples</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">num_class_samples</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">b_a</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">w_a</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">maF</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c">#macro F-Measure</span>
        <span class="n">miF_nom</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c">#micro F-Measure nominator</span>
        <span class="n">miF_den</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c">#micro F-Measure denominator</span>

        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
            <span class="n">metric_str</span><span class="o">=</span><span class="s">&quot;T:&quot;</span><span class="o">+</span><span class="n">label</span><span class="o">+</span><span class="s">&quot;_P:&quot;</span><span class="o">+</span><span class="n">label</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">performance</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">b_a</span> <span class="o">+=</span> <span class="n">performance</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">num_class_samples</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
                <span class="n">w_a</span> <span class="o">+=</span> <span class="n">performance</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">num_class_samples</span><span class="p">[</span><span class="n">label</span><span class="p">])</span><span class="o">*</span><span class="n">weight</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                <span class="n">acc</span> <span class="o">+=</span> <span class="n">performance</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span><span class="o">/</span><span class="n">num_samples</span>
                <span class="n">maF</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">performance</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">num_class_predictions</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">+</span><span class="n">num_class_samples</span><span class="p">[</span><span class="n">label</span><span class="p">]))</span>
                <span class="n">miF_nom</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">performance</span><span class="p">[</span><span class="n">metric_str</span><span class="p">]</span>
            <span class="n">miF_den</span> <span class="o">+=</span> <span class="n">num_class_predictions</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">+</span><span class="n">num_class_samples</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="n">performance</span><span class="p">[</span><span class="s">&quot;Balanced_accuracy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_a</span>
        <span class="n">performance</span><span class="p">[</span><span class="s">&quot;Accuracy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">acc</span>
        <span class="n">performance</span><span class="p">[</span><span class="s">&quot;Weighted_accuracy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_a</span>
        <span class="n">performance</span><span class="p">[</span><span class="s">&quot;macro_average_F_measure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">maF</span>
        <span class="n">performance</span><span class="p">[</span><span class="s">&quot;micro_average_F_measure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">miF_nom</span><span class="o">/</span><span class="n">miF_den</span>

        <span class="n">MC_nom</span> <span class="o">=</span> <span class="n">num_samples</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">num_samples</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="mf">1.0</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">f1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">MC_nom</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="n">k</span><span class="p">,:],</span><span class="n">cm</span><span class="p">[:,</span><span class="n">l</span><span class="p">])</span>
                <span class="n">f1</span>     <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="n">k</span><span class="p">,:],(</span><span class="n">cm</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,</span><span class="n">l</span><span class="p">])</span>
                <span class="n">f2</span>     <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">cm</span><span class="o">.</span><span class="n">T</span><span class="p">)[</span><span class="n">k</span><span class="p">,:],</span><span class="n">cm</span><span class="p">[:,</span><span class="n">l</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">f1</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">f2</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">MCC</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">MCC</span> <span class="o">=</span> <span class="n">MC_nom</span><span class="o">/</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f1</span><span class="p">))</span>

        <span class="n">performance</span><span class="p">[</span><span class="s">&quot;Matthews_correlation_coefficient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MCC</span>

</div></div>
<div class="viewcode-block" id="RegressionDataset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.RegressionDataset">[docs]</a><span class="k">class</span> <span class="nc">RegressionDataset</span><span class="p">(</span><span class="n">BinaryClassificationDataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate 1-dimensional and n-dimensional regression metrics</span>

<span class="sd">    Metrics for 1-dim regression were taken from:</span>

<span class="sd">        - Book: Data mining: practical machine learning tools and techniques</span>
<span class="sd">        - Authors: I. H. Witten and E. Frank</span>
<span class="sd">        - Page: 178</span>
<span class="sd">        - Publisher: Morgan Kaufmann, San Francisco</span>
<span class="sd">        - year: 2005</span>

<span class="sd">    n-dimensional metrics were variants derived by Mario Michael Krell:</span>

<span class="sd">    **micro**</span>

<span class="sd">    For the correlation coefficient, the components were treated</span>
<span class="sd">    like single regression results.</span>
<span class="sd">    For the other metrics, differences and means are taken element or</span>
<span class="sd">    component wise and at the final averaging stage the mean is taken</span>
<span class="sd">    over all components.</span>

<span class="sd">    **component_i_metric**</span>

<span class="sd">    For each dimension,</span>
<span class="sd">    performance values are calculated separately.</span>

<span class="sd">    **macro**</span>

<span class="sd">    The component wise metrics were averaged.</span>


<span class="sd">    :Author: Mario Michael Krell</span>
<span class="sd">    :Created: 2012/11/02</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="RegressionDataset.calculate_metrics"><a class="viewcode-back" href="../../../../api/generated/pySPACE.resources.dataset_defs.metric.html#pySPACE.resources.dataset_defs.metric.RegressionDataset.calculate_metrics">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_metrics</span><span class="p">(</span><span class="n">regression_results</span><span class="p">,</span>
                          <span class="n">time_periods</span><span class="o">=</span><span class="p">[],</span>
                          <span class="n">weight</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate performance measures from the given classifications &quot;&quot;&quot;</span>
        <span class="c"># metric initializations</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="n">metricdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="c"># transform results to distinct lists</span>
        <span class="n">predicted_val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">actual_val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">prediction_vector</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="n">regression_results</span><span class="p">:</span>
            <span class="n">predicted_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prediction_vector</span><span class="o">.</span><span class="n">prediction</span><span class="p">)</span>
            <span class="n">actual_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">actual_val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">predicted_val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">vector_regression</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">predicted_val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">predicted_val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># not type(actual_val[0]) ==list</span>
            <span class="c"># --&gt; automatic parameter mapping to numbers</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_val</span><span class="p">)):</span>
                <span class="n">predicted_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">predicted_val</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">actual_val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">predicted_val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Prediction (</span><span class="si">%s</span><span class="s">) and &quot;</span><span class="o">%</span><span class="nb">type</span><span class="p">(</span><span class="n">predicted_val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                            <span class="s">&quot;real value/label (</span><span class="si">%s</span><span class="s">) should&quot;</span><span class="o">%</span><span class="nb">type</span><span class="p">(</span><span class="n">actual_val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                            <span class="s">&quot; have the same format (list or number/string)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vector_regression</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">predicted_val</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&quot;float64&quot;</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">actual_val</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&quot;float64&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vector_regression</span><span class="p">:</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;mean-squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">p</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;root_mean-squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s">&quot;mean-squared_error&quot;</span><span class="p">])</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;mean_absolute_error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">a</span><span class="p">))</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;relative_squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;mean-squared_error&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;root_relative_squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s">&quot;relative_squared_error&quot;</span><span class="p">])</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;relative absolute error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;mean_absolute_error&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;correlation_coefficient&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># treat arrays like flatten arrays!</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_mean-squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">p</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_root_mean-squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_mean-squared_error&quot;</span><span class="p">])</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_mean_absolute_error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">a</span><span class="p">))</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_relative_squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_mean-squared_error&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_root_relative_squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_relative_squared_error&quot;</span><span class="p">])</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_relative absolute error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_mean_absolute_error&quot;</span><span class="p">]</span> <span class="o">/</span> \
                <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;micro_correlation_coefficient&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">numpy</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                               <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">pre_str</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">metric_names</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;mean-squared_error&quot;</span><span class="p">,</span><span class="s">&quot;root_mean-squared_error&quot;</span><span class="p">,</span>
                          <span class="s">&quot;mean_absolute_error&quot;</span><span class="p">,</span> <span class="s">&quot;relative_squared_error&quot;</span><span class="p">,</span>
                          <span class="s">&quot;root_relative_squared_error&quot;</span><span class="p">,</span>
                          <span class="s">&quot;relative absolute error&quot;</span><span class="p">,</span> <span class="s">&quot;correlation_coefficient&quot;</span><span class="p">]</span>
            <span class="c"># project onto one component and calculate separate performance</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_val</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;component_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;_&quot;</span>
                <span class="n">pre_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">pi</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ai</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;mean-squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">pi</span><span class="o">-</span><span class="n">ai</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;root_mean-squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;mean-squared_error&quot;</span><span class="p">])</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;mean_absolute_error&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pi</span><span class="o">-</span><span class="n">ai</span><span class="p">))</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;relative_squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;mean-squared_error&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;root_relative_squared_error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;relative_squared_error&quot;</span><span class="p">])</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;relative absolute error&quot;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;mean_absolute_error&quot;</span><span class="p">]</span> <span class="o">/</span> \
                    <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ai</span><span class="o">-</span><span class="n">ai</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="s">&quot;correlation_coefficient&quot;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">numpy</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">pi</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metric_names</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">pre</span> <span class="ow">in</span> <span class="n">pre_str</span><span class="p">:</span>
                    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metrics</span><span class="p">[</span><span class="n">pre</span><span class="o">+</span><span class="n">metric</span><span class="p">])</span>
                <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;macro_&quot;</span><span class="o">+</span><span class="n">metric</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">classifier_information</span> <span class="o">=</span> \
                    <span class="n">regression_results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">predictor</span><span class="o">.</span><span class="n">classifier_information</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">classifier_information</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">metrics</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c">### Time metrics ###</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="c"># the first measured time can be inaccurate due to</span>
            <span class="c"># initialization procedures performed in the first executions</span>
            <span class="n">time_periods</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Time (average)&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="mf">1.</span><span class="o">/</span><span class="mi">1000</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span>
            <span class="n">metrics</span><span class="p">[</span><span class="s">&quot;Time (maximal)&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">1000</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">time_periods</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">metrics</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">pySPACE 0.5 alpha documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, pySPACE Developer Team.
      Last updated on Aug 07, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>